{
	"type": "excalidraw",
	"version": 2,
	"source": "https://github.com/zsviczian/obsidian-excalidraw-plugin/releases/tag/1.9.24",
	"elements": [
		{
			"type": "rectangle",
			"version": 499,
			"versionNonce": 2069758360,
			"isDeleted": false,
			"id": "AV9wkqK40_PERvDCdmDZd",
			"fillStyle": "hachure",
			"strokeWidth": 1,
			"strokeStyle": "solid",
			"roughness": 1,
			"opacity": 100,
			"angle": 0,
			"x": -1028.9767746710625,
			"y": -198.91903284178773,
			"strokeColor": "#1e1e1e",
			"backgroundColor": "transparent",
			"width": 450.4503544544633,
			"height": 414.4299035312007,
			"seed": 2141732632,
			"groupIds": [],
			"frameId": null,
			"roundness": {
				"type": 3
			},
			"boundElements": [
				{
					"id": "tp1WtFZcCu8-NNpurnPc2",
					"type": "arrow"
				}
			],
			"updated": 1700390730218,
			"link": null,
			"locked": false
		},
		{
			"type": "text",
			"version": 619,
			"versionNonce": 2077810091,
			"isDeleted": false,
			"id": "dkUZOiEe",
			"fillStyle": "hachure",
			"strokeWidth": 1,
			"strokeStyle": "solid",
			"roughness": 1,
			"opacity": 100,
			"angle": 0,
			"x": -1023.9767746710625,
			"y": -183.70408107618738,
			"strokeColor": "#1e1e1e",
			"backgroundColor": "#ffffff",
			"width": 419.765625,
			"height": 384,
			"seed": 1540413544,
			"groupIds": [],
			"frameId": null,
			"roundness": null,
			"boundElements": [],
			"updated": 1700528303911,
			"link": null,
			"locked": false,
			"fontSize": 20,
			"fontFamily": 4,
			"text": "基本命令：\nlength(x)\nx<-c(1,2,3)\nls()\nx=norm(10)//产生随机正态变量的向量\ncor(x,y)计算相关系数\nmean() 均值\nvay(y) 方差\nsd(y) 标准差\nplot()散点图\nseq(0,1,lenght=10) seq(1,10)\n\ndim(Auto) 查看数据集维度\nnames(Auto) 查看数据集变量名\nhist(mpg) 直方图\npair(~mpg+a+b+c) 建立每一对变量之间的散点图",
			"rawText": "基本命令：\nlength(x)\nx<-c(1,2,3)\nls()\nx=norm(10)//产生随机正态变量的向量\ncor(x,y)计算相关系数\nmean() 均值\nvay(y) 方差\nsd(y) 标准差\nplot()散点图\nseq(0,1,lenght=10) seq(1,10)\n\ndim(Auto) 查看数据集维度\nnames(Auto) 查看数据集变量名\nhist(mpg) 直方图\npair(~mpg+a+b+c) 建立每一对变量之间的散点图",
			"textAlign": "left",
			"verticalAlign": "middle",
			"containerId": null,
			"originalText": "基本命令：\nlength(x)\nx<-c(1,2,3)\nls()\nx=norm(10)//产生随机正态变量的向量\ncor(x,y)计算相关系数\nmean() 均值\nvay(y) 方差\nsd(y) 标准差\nplot()散点图\nseq(0,1,lenght=10) seq(1,10)\n\ndim(Auto) 查看数据集维度\nnames(Auto) 查看数据集变量名\nhist(mpg) 直方图\npair(~mpg+a+b+c) 建立每一对变量之间的散点图",
			"lineHeight": 1.2,
			"baseline": 379
		},
		{
			"type": "line",
			"version": 21,
			"versionNonce": 945426072,
			"isDeleted": false,
			"id": "qhUo8tAD_OKtuX4VjdnDJ",
			"fillStyle": "hachure",
			"strokeWidth": 1,
			"strokeStyle": "solid",
			"roughness": 1,
			"opacity": 100,
			"angle": 0,
			"x": -622.3496866619705,
			"y": 42.68665073533606,
			"strokeColor": "#ffffff",
			"backgroundColor": "#ffffff",
			"width": 78.39398193359375,
			"height": 3.346099853515625,
			"seed": 1850476991,
			"groupIds": [],
			"frameId": null,
			"roundness": {
				"type": 2
			},
			"boundElements": [],
			"updated": 1700390730218,
			"link": null,
			"locked": false,
			"startBinding": null,
			"endBinding": null,
			"lastCommittedPoint": null,
			"startArrowhead": null,
			"endArrowhead": null,
			"points": [
				[
					0,
					0
				],
				[
					-78.39398193359375,
					-3.346099853515625
				]
			]
		},
		{
			"type": "arrow",
			"version": 221,
			"versionNonce": 2118158827,
			"isDeleted": false,
			"id": "tp1WtFZcCu8-NNpurnPc2",
			"fillStyle": "hachure",
			"strokeWidth": 1,
			"strokeStyle": "solid",
			"roughness": 1,
			"opacity": 100,
			"angle": 0,
			"x": -481.3165035758102,
			"y": 255.02527101102893,
			"strokeColor": "#ffffff",
			"backgroundColor": "#ffffff",
			"width": 69.8093061330353,
			"height": 70.3103385232809,
			"seed": 171480529,
			"groupIds": [],
			"frameId": null,
			"roundness": {
				"type": 2
			},
			"boundElements": [],
			"updated": 1700527974442,
			"link": null,
			"locked": false,
			"startBinding": {
				"elementId": "vz4MX5rLBunYdmK1zCnQ_",
				"gap": 14.968780752006637,
				"focus": -0.14284904089733233
			},
			"endBinding": {
				"elementId": "AV9wkqK40_PERvDCdmDZd",
				"gap": 27.400610507753697,
				"focus": -0.17974593233691788
			},
			"lastCommittedPoint": null,
			"startArrowhead": null,
			"endArrowhead": "arrow",
			"points": [
				[
					0,
					0
				],
				[
					-69.8093061330353,
					-70.3103385232809
				]
			]
		},
		{
			"type": "arrow",
			"version": 167,
			"versionNonce": 437024939,
			"isDeleted": false,
			"id": "A9fSppge97BlYFYvH5ayL",
			"fillStyle": "hachure",
			"strokeWidth": 1,
			"strokeStyle": "solid",
			"roughness": 1,
			"opacity": 100,
			"angle": 0,
			"x": -455.22575346948787,
			"y": -162.8851004420436,
			"strokeColor": "#ffffff",
			"backgroundColor": "#ffffff",
			"width": 5.555756922951389,
			"height": 223.73624092347342,
			"seed": 1157277855,
			"groupIds": [],
			"frameId": null,
			"roundness": {
				"type": 2
			},
			"boundElements": [],
			"updated": 1700527974441,
			"link": null,
			"locked": false,
			"startBinding": {
				"elementId": "vz4MX5rLBunYdmK1zCnQ_",
				"gap": 20.30869755985634,
				"focus": -1.0740985291757337
			},
			"endBinding": null,
			"lastCommittedPoint": null,
			"startArrowhead": null,
			"endArrowhead": "arrow",
			"points": [
				[
					0,
					0
				],
				[
					-5.555756922951389,
					223.73624092347342
				]
			]
		},
		{
			"type": "rectangle",
			"version": 206,
			"versionNonce": 561818088,
			"isDeleted": false,
			"id": "vz4MX5rLBunYdmK1zCnQ_",
			"fillStyle": "hachure",
			"strokeWidth": 1,
			"strokeStyle": "solid",
			"roughness": 1,
			"opacity": 100,
			"angle": 0,
			"x": -466.34772282380357,
			"y": -179.8775986179851,
			"strokeColor": "#1e1e1e",
			"backgroundColor": "transparent",
			"width": 496.08486325595027,
			"height": 1162,
			"seed": 2105350911,
			"groupIds": [],
			"frameId": null,
			"roundness": {
				"type": 3
			},
			"boundElements": [
				{
					"id": "A9fSppge97BlYFYvH5ayL",
					"type": "arrow"
				},
				{
					"id": "tp1WtFZcCu8-NNpurnPc2",
					"type": "arrow"
				},
				{
					"type": "text",
					"id": "tKX1nohS"
				}
			],
			"updated": 1700390730218,
			"link": null,
			"locked": false
		},
		{
			"type": "text",
			"version": 864,
			"versionNonce": 1426986123,
			"isDeleted": false,
			"id": "tKX1nohS",
			"fillStyle": "hachure",
			"strokeWidth": 1,
			"strokeStyle": "solid",
			"roughness": 1,
			"opacity": 100,
			"angle": 0,
			"x": -461.34772282380357,
			"y": -174.8775986179851,
			"strokeColor": "#1e1e1e",
			"backgroundColor": "transparent",
			"width": 482.34375,
			"height": 1152,
			"seed": 550711199,
			"groupIds": [],
			"frameId": null,
			"roundness": null,
			"boundElements": [],
			"updated": 1700527974461,
			"link": null,
			"locked": false,
			"fontSize": 20,
			"fontFamily": 4,
			"text": "线性回归\nlm.fit=lm(medv~lstat,data=Auto) \n拟合medv与lstat的简单线性回归模型\n\ncoef(lm.fit) 提取拟合系数\nconfint(lm.fit) 系数估计值的置信区间\npredict(lm.fit,data.frame(lstat=c(5,10,15),interval=''\n当lstat=c[i]时\ninterval='confidence' 计算95%置信区间\ninterval='prediction' 计算95%预测区间\n\nabline(lm.fit) 绘制直线\nabline(b,k) 绘制斜率为k，截距为b的直线\npar(mfrow=c(2,2)) 将绘制区域划分为2*2网络面板\n\nresiduals(lm.fit) 计算线性回归拟合的残差\nrstudent(lm.fit) 计算学生化残差\nhatvalues(lm.fit) 计算杠杆统计量\n\n多元线性回归\n\nlm.fit=lm(medv~lstat+age,data=Auto)\n拟合medv与lstat和age多元线性回归模型\n\nlm.fit=lm(medv~.,data=Auto)\n拟合medv与所有变量的多元线性回归模型\n\nlm.fit=lm(medv~.-age,data=Auto)\n拟合medv与除age外所有变量的多元线性回归模型\n\nlm.fit=lm(medv~lstat*age,data=Auto)\n拟合medv与age lstat和他们交互项的多元线性回归模型\n\nlm.fit=lm(medv~lstat+I(lstat^2),data=Auto)\n拟合medv与lstat和lstat二次项的多元线性回归模型\n\nlm.fit=lm(medv~poly(lstat,5),data=Auto)\n拟合medv与lstat的五阶多项式的多元线性回归模型\n\ncontrasts(ShelveLoc) 返回虚拟变量的编码\n\n\n\n\n\n\n\n",
			"rawText": "线性回归\nlm.fit=lm(medv~lstat,data=Auto) \n拟合medv与lstat的简单线性回归模型\n\ncoef(lm.fit) 提取拟合系数\nconfint(lm.fit) 系数估计值的置信区间\npredict(lm.fit,data.frame(lstat=c(5,10,15),interval=''\n当lstat=c[i]时\ninterval='confidence' 计算95%置信区间\ninterval='prediction' 计算95%预测区间\n\nabline(lm.fit) 绘制直线\nabline(b,k) 绘制斜率为k，截距为b的直线\npar(mfrow=c(2,2)) 将绘制区域划分为2*2网络面板\n\nresiduals(lm.fit) 计算线性回归拟合的残差\nrstudent(lm.fit) 计算学生化残差\nhatvalues(lm.fit) 计算杠杆统计量\n\n多元线性回归\n\nlm.fit=lm(medv~lstat+age,data=Auto)\n拟合medv与lstat和age多元线性回归模型\n\nlm.fit=lm(medv~.,data=Auto)\n拟合medv与所有变量的多元线性回归模型\n\nlm.fit=lm(medv~.-age,data=Auto)\n拟合medv与除age外所有变量的多元线性回归模型\n\nlm.fit=lm(medv~lstat*age,data=Auto)\n拟合medv与age lstat和他们交互项的多元线性回归模型\n\nlm.fit=lm(medv~lstat+I(lstat^2),data=Auto)\n拟合medv与lstat和lstat二次项的多元线性回归模型\n\nlm.fit=lm(medv~poly(lstat,5),data=Auto)\n拟合medv与lstat的五阶多项式的多元线性回归模型\n\ncontrasts(ShelveLoc) 返回虚拟变量的编码\n\n\n\n\n\n\n\n",
			"textAlign": "left",
			"verticalAlign": "middle",
			"containerId": "vz4MX5rLBunYdmK1zCnQ_",
			"originalText": "线性回归\nlm.fit=lm(medv~lstat,data=Auto) \n拟合medv与lstat的简单线性回归模型\n\ncoef(lm.fit) 提取拟合系数\nconfint(lm.fit) 系数估计值的置信区间\npredict(lm.fit,data.frame(lstat=c(5,10,15),interval=''\n当lstat=c[i]时\ninterval='confidence' 计算95%置信区间\ninterval='prediction' 计算95%预测区间\n\nabline(lm.fit) 绘制直线\nabline(b,k) 绘制斜率为k，截距为b的直线\npar(mfrow=c(2,2)) 将绘制区域划分为2*2网络面板\n\nresiduals(lm.fit) 计算线性回归拟合的残差\nrstudent(lm.fit) 计算学生化残差\nhatvalues(lm.fit) 计算杠杆统计量\n\n多元线性回归\n\nlm.fit=lm(medv~lstat+age,data=Auto)\n拟合medv与lstat和age多元线性回归模型\n\nlm.fit=lm(medv~.,data=Auto)\n拟合medv与所有变量的多元线性回归模型\n\nlm.fit=lm(medv~.-age,data=Auto)\n拟合medv与除age外所有变量的多元线性回归模型\n\nlm.fit=lm(medv~lstat*age,data=Auto)\n拟合medv与age lstat和他们交互项的多元线性回归模型\n\nlm.fit=lm(medv~lstat+I(lstat^2),data=Auto)\n拟合medv与lstat和lstat二次项的多元线性回归模型\n\nlm.fit=lm(medv~poly(lstat,5),data=Auto)\n拟合medv与lstat的五阶多项式的多元线性回归模型\n\ncontrasts(ShelveLoc) 返回虚拟变量的编码\n\n\n\n\n\n\n\n",
			"lineHeight": 1.2,
			"baseline": 1146
		},
		{
			"type": "rectangle",
			"version": 349,
			"versionNonce": 1528769768,
			"isDeleted": false,
			"id": "vebZP9OEAyEx-smK_QFYc",
			"fillStyle": "hachure",
			"strokeWidth": 1,
			"strokeStyle": "solid",
			"roughness": 1,
			"opacity": 100,
			"angle": 0,
			"x": 64.92513886799873,
			"y": -231.53066525479437,
			"strokeColor": "#1e1e1e",
			"backgroundColor": "transparent",
			"width": 542.4081057194214,
			"height": 1162,
			"seed": 749925761,
			"groupIds": [],
			"frameId": null,
			"roundness": {
				"type": 3
			},
			"boundElements": [
				{
					"type": "text",
					"id": "s1hBRgWV"
				}
			],
			"updated": 1700390730218,
			"link": null,
			"locked": false
		},
		{
			"type": "text",
			"version": 1495,
			"versionNonce": 454118187,
			"isDeleted": false,
			"id": "s1hBRgWV",
			"fillStyle": "hachure",
			"strokeWidth": 1,
			"strokeStyle": "solid",
			"roughness": 1,
			"opacity": 100,
			"angle": 0,
			"x": 69.92513886799873,
			"y": 25.46933474520563,
			"strokeColor": "#1e1e1e",
			"backgroundColor": "transparent",
			"width": 506.25,
			"height": 648,
			"seed": 1620745569,
			"groupIds": [],
			"frameId": null,
			"roundness": null,
			"boundElements": [],
			"updated": 1700527974472,
			"link": null,
			"locked": false,
			"fontSize": 20,
			"fontFamily": 4,
			"text": "线性模型选择\n\n最优子集选择\nHitters=na.omit(Hitters) \n删除在任何变量上存在缺失值的预测\n\nregsubset()\n实现最优预测变量子集的筛选，默认筛选最优八变量\nrefir.full=resubset(Salary~.,Hitters)\n建立Salary与全变量的最优八变量模型\n\nrefir.full=resubset(Salary~.,Hitters,nvmax=19)\n建立Salary与全变量的最优19变量模型\n\nwhich.max(reg.summary$adjr2) 识别向量中最大值对应位置\npoints(x,y,,col='red',cex=2,pch=20) 将点加在已知图像上\n\n向前逐步选择和向后逐步选择\nregit.select=regsubset(Salary~.,data=Hitters,method='')\nmethod='forward' 向前逐步选择\nmethod='backwawd' 向后逐步选择\n\n使用验证集方法和交叉验证选择模型\n\n \n\n",
			"rawText": "线性模型选择\n\n最优子集选择\nHitters=na.omit(Hitters) \n删除在任何变量上存在缺失值的预测\n\nregsubset()\n实现最优预测变量子集的筛选，默认筛选最优八变量\nrefir.full=resubset(Salary~.,Hitters)\n建立Salary与全变量的最优八变量模型\n\nrefir.full=resubset(Salary~.,Hitters,nvmax=19)\n建立Salary与全变量的最优19变量模型\n\nwhich.max(reg.summary$adjr2) 识别向量中最大值对应位置\npoints(x,y,,col='red',cex=2,pch=20) 将点加在已知图像上\n\n向前逐步选择和向后逐步选择\nregit.select=regsubset(Salary~.,data=Hitters,method='')\nmethod='forward' 向前逐步选择\nmethod='backwawd' 向后逐步选择\n\n使用验证集方法和交叉验证选择模型\n\n \n\n",
			"textAlign": "left",
			"verticalAlign": "middle",
			"containerId": "vebZP9OEAyEx-smK_QFYc",
			"originalText": "线性模型选择\n\n最优子集选择\nHitters=na.omit(Hitters) \n删除在任何变量上存在缺失值的预测\n\nregsubset()\n实现最优预测变量子集的筛选，默认筛选最优八变量\nrefir.full=resubset(Salary~.,Hitters)\n建立Salary与全变量的最优八变量模型\n\nrefir.full=resubset(Salary~.,Hitters,nvmax=19)\n建立Salary与全变量的最优19变量模型\n\nwhich.max(reg.summary$adjr2) 识别向量中最大值对应位置\npoints(x,y,,col='red',cex=2,pch=20) 将点加在已知图像上\n\n向前逐步选择和向后逐步选择\nregit.select=regsubset(Salary~.,data=Hitters,method='')\nmethod='forward' 向前逐步选择\nmethod='backwawd' 向后逐步选择\n\n使用验证集方法和交叉验证选择模型\n\n \n\n",
			"lineHeight": 1.2,
			"baseline": 642
		},
		{
			"type": "rectangle",
			"version": 447,
			"versionNonce": 1668894696,
			"isDeleted": false,
			"id": "dgd-yxztSNrXr1Nt4kmfX",
			"fillStyle": "hachure",
			"strokeWidth": 1,
			"strokeStyle": "solid",
			"roughness": 1,
			"opacity": 100,
			"angle": 0,
			"x": 693.0020229338666,
			"y": -217.31374353834303,
			"strokeColor": "#1e1e1e",
			"backgroundColor": "transparent",
			"width": 650.4062125237374,
			"height": 1162,
			"seed": 1157042417,
			"groupIds": [],
			"frameId": null,
			"roundness": {
				"type": 3
			},
			"boundElements": [
				{
					"type": "text",
					"id": "RvaJwLZu"
				}
			],
			"updated": 1700390730218,
			"link": null,
			"locked": false
		},
		{
			"type": "text",
			"version": 1975,
			"versionNonce": 884256203,
			"isDeleted": false,
			"id": "RvaJwLZu",
			"fillStyle": "hachure",
			"strokeWidth": 1,
			"strokeStyle": "solid",
			"roughness": 1,
			"opacity": 100,
			"angle": 0,
			"x": 698.0020229338666,
			"y": -212.31374353834303,
			"strokeColor": "#1e1e1e",
			"backgroundColor": "transparent",
			"width": 636.2890625,
			"height": 1152,
			"seed": 1923730129,
			"groupIds": [],
			"frameId": null,
			"roundness": null,
			"boundElements": [],
			"updated": 1700527974485,
			"link": null,
			"locked": false,
			"fontSize": 20,
			"fontFamily": 4,
			"text": "重抽样方法\nglm.fits=glm(default~income+balance,family=binomial,data=Default)\n在Defalult数据集中用income和balance来预测default的概率的逻辑斯蒂\n回归模型\n\nboot.fn=function(data,index){\nreturn(coef(glm(default~income+balance,family=binomial,data=Default,\nsubset=index)))\n}\n函数boot.fn，输入参数是Defalut数据集和观测的序号，返回逻辑斯蒂回\n归模型中income和balance系数的估计\n\nglm.fit = glm(y ~ x)\ncv.glm(Data, glm.fit)$delta\n用留一法对glm拟合模型的测试误差进行交叉验证\n\nmedv.mean = mean(medv) medv总体均值的估计\nmedv.med = median(medv) medv总体中位数的估计\nmedv.tenth = quantile(medv, c(0.1)) 数据集medv的10%分位数估计\nboot.fn = function(data, index) return(quantile(data[index], c(0.1)))\nboot(medv, boot.fn, 1000)\n用自助法来估计medv的10%分位数及标准误差\n\nX = rnorm(100)\n生成长度为100的预测变量\n\nmod.full = regsubsets(y ~ poly(x, 10, raw = T), data = data.full, nvmax =\n10)\n从包含预测变量的模型中选择最优10变量模型\n\nlm.fit = lm(Apps~., data=College.train)\n在训练集上拟合最小二乘模型\n\n\nlambda.best 使得交叉验证误差最小的lamda\n\nmod.ridge = cv.glmnet(train.mat, College.train[, \"Apps\"], alpha=0, \nlambda=grid, thresh=1e-12)\n在训练集上拟合岭回归模型，并使用交叉验证选择lamda的值\n\nmod.lasso = cv.glmnet(train.mat, College.train[, \"Apps\"], alpha=1, \nlambda=grid, thresh=1e-12)\n在训练集上拟合lasso回归模型，并使用交叉验证选择lamba的值\n\n\n\n\n",
			"rawText": "重抽样方法\nglm.fits=glm(default~income+balance,family=binomial,data=Default)\n在Defalult数据集中用income和balance来预测default的概率的逻辑斯蒂回归模型\n\nboot.fn=function(data,index){\nreturn(coef(glm(default~income+balance,family=binomial,data=Default,subset=index)))\n}\n函数boot.fn，输入参数是Defalut数据集和观测的序号，返回逻辑斯蒂回归模型中income和balance系数的估计\n\nglm.fit = glm(y ~ x)\ncv.glm(Data, glm.fit)$delta\n用留一法对glm拟合模型的测试误差进行交叉验证\n\nmedv.mean = mean(medv) medv总体均值的估计\nmedv.med = median(medv) medv总体中位数的估计\nmedv.tenth = quantile(medv, c(0.1)) 数据集medv的10%分位数估计\nboot.fn = function(data, index) return(quantile(data[index], c(0.1)))\nboot(medv, boot.fn, 1000)\n用自助法来估计medv的10%分位数及标准误差\n\nX = rnorm(100)\n生成长度为100的预测变量\n\nmod.full = regsubsets(y ~ poly(x, 10, raw = T), data = data.full, nvmax = 10)\n从包含预测变量的模型中选择最优10变量模型\n\nlm.fit = lm(Apps~., data=College.train)\n在训练集上拟合最小二乘模型\n\n\nlambda.best 使得交叉验证误差最小的lamda\n\nmod.ridge = cv.glmnet(train.mat, College.train[, \"Apps\"], alpha=0, lambda=grid, thresh=1e-12)\n在训练集上拟合岭回归模型，并使用交叉验证选择lamda的值\n\nmod.lasso = cv.glmnet(train.mat, College.train[, \"Apps\"], alpha=1, lambda=grid, thresh=1e-12)\n在训练集上拟合lasso回归模型，并使用交叉验证选择lamba的值\n\n\n\n\n",
			"textAlign": "left",
			"verticalAlign": "middle",
			"containerId": "dgd-yxztSNrXr1Nt4kmfX",
			"originalText": "重抽样方法\nglm.fits=glm(default~income+balance,family=binomial,data=Default)\n在Defalult数据集中用income和balance来预测default的概率的逻辑斯蒂回归模型\n\nboot.fn=function(data,index){\nreturn(coef(glm(default~income+balance,family=binomial,data=Default,subset=index)))\n}\n函数boot.fn，输入参数是Defalut数据集和观测的序号，返回逻辑斯蒂回归模型中income和balance系数的估计\n\nglm.fit = glm(y ~ x)\ncv.glm(Data, glm.fit)$delta\n用留一法对glm拟合模型的测试误差进行交叉验证\n\nmedv.mean = mean(medv) medv总体均值的估计\nmedv.med = median(medv) medv总体中位数的估计\nmedv.tenth = quantile(medv, c(0.1)) 数据集medv的10%分位数估计\nboot.fn = function(data, index) return(quantile(data[index], c(0.1)))\nboot(medv, boot.fn, 1000)\n用自助法来估计medv的10%分位数及标准误差\n\nX = rnorm(100)\n生成长度为100的预测变量\n\nmod.full = regsubsets(y ~ poly(x, 10, raw = T), data = data.full, nvmax = 10)\n从包含预测变量的模型中选择最优10变量模型\n\nlm.fit = lm(Apps~., data=College.train)\n在训练集上拟合最小二乘模型\n\n\nlambda.best 使得交叉验证误差最小的lamda\n\nmod.ridge = cv.glmnet(train.mat, College.train[, \"Apps\"], alpha=0, lambda=grid, thresh=1e-12)\n在训练集上拟合岭回归模型，并使用交叉验证选择lamda的值\n\nmod.lasso = cv.glmnet(train.mat, College.train[, \"Apps\"], alpha=1, lambda=grid, thresh=1e-12)\n在训练集上拟合lasso回归模型，并使用交叉验证选择lamba的值\n\n\n\n\n",
			"lineHeight": 1.2,
			"baseline": 1146
		},
		{
			"type": "rectangle",
			"version": 65,
			"versionNonce": 1117197032,
			"isDeleted": false,
			"id": "SFF7avW4liiLhgfr3PghC",
			"fillStyle": "hachure",
			"strokeWidth": 1,
			"strokeStyle": "solid",
			"roughness": 1,
			"opacity": 100,
			"angle": 0,
			"x": 723.0029364756863,
			"y": 1016.7772458909769,
			"strokeColor": "#1e1e1e",
			"backgroundColor": "transparent",
			"width": 653.5749260649745,
			"height": 754,
			"seed": 1193051729,
			"groupIds": [],
			"frameId": null,
			"roundness": {
				"type": 3
			},
			"boundElements": [
				{
					"type": "text",
					"id": "X17jtJGD"
				}
			],
			"updated": 1700390730218,
			"link": null,
			"locked": false
		},
		{
			"type": "text",
			"version": 111,
			"versionNonce": 353549419,
			"isDeleted": false,
			"id": "X17jtJGD",
			"fillStyle": "hachure",
			"strokeWidth": 1,
			"strokeStyle": "solid",
			"roughness": 1,
			"opacity": 100,
			"angle": 0,
			"x": 728.0029364756863,
			"y": 1021.7772458909769,
			"strokeColor": "#1e1e1e",
			"backgroundColor": "transparent",
			"width": 640,
			"height": 744,
			"seed": 1461841585,
			"groupIds": [],
			"frameId": null,
			"roundness": null,
			"boundElements": [],
			"updated": 1700527974491,
			"link": null,
			"locked": false,
			"fontSize": 20,
			"fontFamily": 4,
			"text": "regfit.full = regsubsets(y ~ ., data = data.frame(x = x.train, y = \ny.train), nvmax = p)\nval.errors = rep(NA, p)\nx_cols = colnames(x, do.NULL = FALSE, prefix = \"x.\")\nfor (i in 1:p)\n{\n    coefi = coef(regfit.full, id = i)\n    pred = as.matrix(x.train[, x_cols %in% names(coefi)]) %*% \ncoefi[names(coefi) %in%x_cols]\n    val.errors[i] = mean((y.train - pred)^2)\n}\nplot(val.errors, ylab = \"Training MSE\", pch = 19, type = \"b\")\n基于训练集使用最优子集选择法，并作出不同模型大小下最优模型的训练\n集MSE\n\nval.errors = rep(NA, p)\nfor (i in 1:p) {\n    coefi = coef(regfit.full, id = i)\n    pred = as.matrix(x.test[, x_cols %in% names(coefi)]) %*% \ncoefi[names(coefi) %in% \n        x_cols]\n    val.errors[i] = mean((y.test - pred)^2)\n}\nplot(val.errors, ylab = \"Test MSE\", pch = 19, type = \"b\")\n作出不同模型大小下的测试机MSE\n\nwhich.min(val.errors)\n具有最小测试集MSE的特征数\n\n\n",
			"rawText": "regfit.full = regsubsets(y ~ ., data = data.frame(x = x.train, y = y.train), nvmax = p)\nval.errors = rep(NA, p)\nx_cols = colnames(x, do.NULL = FALSE, prefix = \"x.\")\nfor (i in 1:p)\n{\n    coefi = coef(regfit.full, id = i)\n    pred = as.matrix(x.train[, x_cols %in% names(coefi)]) %*% coefi[names(coefi) %in%x_cols]\n    val.errors[i] = mean((y.train - pred)^2)\n}\nplot(val.errors, ylab = \"Training MSE\", pch = 19, type = \"b\")\n基于训练集使用最优子集选择法，并作出不同模型大小下最优模型的训练集MSE\n\nval.errors = rep(NA, p)\nfor (i in 1:p) {\n    coefi = coef(regfit.full, id = i)\n    pred = as.matrix(x.test[, x_cols %in% names(coefi)]) %*% coefi[names(coefi) %in% \n        x_cols]\n    val.errors[i] = mean((y.test - pred)^2)\n}\nplot(val.errors, ylab = \"Test MSE\", pch = 19, type = \"b\")\n作出不同模型大小下的测试机MSE\n\nwhich.min(val.errors)\n具有最小测试集MSE的特征数\n\n\n",
			"textAlign": "left",
			"verticalAlign": "middle",
			"containerId": "SFF7avW4liiLhgfr3PghC",
			"originalText": "regfit.full = regsubsets(y ~ ., data = data.frame(x = x.train, y = y.train), nvmax = p)\nval.errors = rep(NA, p)\nx_cols = colnames(x, do.NULL = FALSE, prefix = \"x.\")\nfor (i in 1:p)\n{\n    coefi = coef(regfit.full, id = i)\n    pred = as.matrix(x.train[, x_cols %in% names(coefi)]) %*% coefi[names(coefi) %in%x_cols]\n    val.errors[i] = mean((y.train - pred)^2)\n}\nplot(val.errors, ylab = \"Training MSE\", pch = 19, type = \"b\")\n基于训练集使用最优子集选择法，并作出不同模型大小下最优模型的训练集MSE\n\nval.errors = rep(NA, p)\nfor (i in 1:p) {\n    coefi = coef(regfit.full, id = i)\n    pred = as.matrix(x.test[, x_cols %in% names(coefi)]) %*% coefi[names(coefi) %in% \n        x_cols]\n    val.errors[i] = mean((y.test - pred)^2)\n}\nplot(val.errors, ylab = \"Test MSE\", pch = 19, type = \"b\")\n作出不同模型大小下的测试机MSE\n\nwhich.min(val.errors)\n具有最小测试集MSE的特征数\n\n\n",
			"lineHeight": 1.2,
			"baseline": 739
		}
	],
	"appState": {
		"theme": "light",
		"viewBackgroundColor": "#ffffff",
		"currentItemStrokeColor": "#1e1e1e",
		"currentItemBackgroundColor": "transparent",
		"currentItemFillStyle": "hachure",
		"currentItemStrokeWidth": 1,
		"currentItemStrokeStyle": "solid",
		"currentItemRoughness": 1,
		"currentItemOpacity": 100,
		"currentItemFontFamily": 4,
		"currentItemFontSize": 20,
		"currentItemTextAlign": "left",
		"currentItemStartArrowhead": null,
		"currentItemEndArrowhead": "arrow",
		"scrollX": 1867.310567176312,
		"scrollY": 375.9322652374642,
		"zoom": {
			"value": 0.45
		},
		"currentItemRoundness": "round",
		"gridSize": null,
		"gridColor": {
			"Bold": "#C9C9C9FF",
			"Regular": "#EDEDEDFF"
		},
		"currentStrokeOptions": null,
		"previousGridSize": null,
		"frameRendering": {
			"enabled": true,
			"clip": true,
			"name": true,
			"outline": true
		}
	},
	"files": {}
}