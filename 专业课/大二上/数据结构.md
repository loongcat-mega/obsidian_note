## 数据结构

1. 线性结构：线性表、栈与递归、队列、字符串
2. 树和二叉树：树的存储、树与二叉树关系、二叉树存储、二叉树遍历、线索二叉树；基于树和二叉树的常用算法：二叉搜索树、堆
3. 图：图的存储、图的遍历；基于图的常用算法：最短路径、最小生成树
4. 散列表：散列函数、散列冲突的处理

逻辑结构与存储结构的关系？


---
## 线性表

#### 顺序表
ACN:平均比较次数，O(n):算法的平均时间复杂度
| 操作 | ACN | O(n) |
| ---- | --- | ---- |
| 查找 |  $\frac{1+n}{2}$   |    n  |
| 插入 |   $\frac{n}{2}$  |     n |
| 删除 |   $\frac{n-1}{2}$  |     n |

数组顺序表就是一个随机存储结构

#### 链表

可以动态的申请内存空间，根据线性表元素的数目动态地改变所需要的存储空间

	元素的插入与删除
	单链表的翻转
	合并两个有序链表

#### 栈

后进先出 LIFO

	数制转换
	迷宫问题求解
	表达式计算
###### 递归

	全排列

#### 队列

先进先出 FIFO

循环数组：在逻辑上将数组看成一个环

把存储n个元素的数组大小设置为n+1，牺牲一个元素的空间来简化操作和提高效率
```c++
MaxSize=n+1;

rear=(rear+1)%MaxSize;

front=(front+1)%MaxSize;
```

	打印杨辉三角

#### 字符串

#### KMP
###### 特征向量
```c++
int *Next(string P)
{
	int m=P.size();
	int *N=new int[m];
	N[0]=0;
	for(int j=1;j<m;j++)//对P的每一个位置进行分析
	{
		int k=N[j-1];
		while(k>0&&P[j]!=p[k])
			k=N[k-1];
		if(P[j]==P[k])
			N[j]=k+1;
		else
			N[j]=0;
	}
	return N;
}
```
###### KMP模式匹配算法
```c++
int KMPStrMatching(string T,string P,int *N,int startIndex)
{
	int lastIndex=T.size()-P.size();
	if(lastIndex<startIndex)
		return -1;
	int i=startIndex;//目标的下标变量
	int j=0;//模式的下标变量
	while(i<T.size()&&j<P.size())
	{
		if(P[j]==T[i])
		{
			j++;
			i++;
		}
		else if(j!=0)
			j=N[j-1];
		else
			i++;
	}
	if(j==P.size())
		return i-j;
	reutn -1;	
}
```


---

## 树

#### 树的基本概念
###### 树的定义

叶子结点：没有孩子结点的结点
分枝结点：非叶子结点
结点的度：该结点所拥有孩子结点的数量
树的度：树中所有结点度的最大值
结点的层数：从根节点开始定义，根节点层数为0
树的深度：所有结点层数的最大值
树的高度：树的深度+1

###### 树的基本性质

树中的结点数等于所有结点度数之和加1
度为m的树，其第i层上至多有$m^i$个结点
高度为h，度为m的树至多有$\frac{m^h-1}{m-1}$个结点
具有n个结点的度为m的树，其最小高度为$\lceil  log_m(n(m-1)+1) \rceil$

#### 二叉树

具有n个结点的二叉树形态：
$$C_n=\frac{(2n)!}{n!(n+1)!}$$


所有结点的度小于等于2

##### 几种特殊的二叉树

###### 完全二叉树

一颗高度为h的二叉树，除最后一层以外的其他所有层的结点都达到最大值，而最后一层的所有结点分布在该层最左边的连续的位置上

叶子结点只能在层次最大和次大的两个层次上出现

对任一结点，如果其左子树高度为m，则其右子树的高度必为m或m-1

###### 满二叉树

二叉树的所有的分支结点都有非空左子树和非空右子树，并且所有叶子结点都在同一层次

高度为h的满二叉树有$2^h-1$个结点

每一层上结点数量都达到最大个数，所有分支结点的度都为2，叶子结点都出现在最后一层

###### 扩充二叉树

把原二叉树的所有结点中出现空的子树的位置都增加上特殊节点——空树叶

外部路径长度：E
内部路径长度：I
$$E=I+2n$$

##### 二叉树性质

任何一棵二叉树，度为0的结点的度比度为2的结点多一个
$$n_0=n_2+1$$

##### 二叉树的存储结构

###### 顺序存储

存储完全二叉树

###### 链式存储

邻接表的头结点数等于顶点数

##### [[线索二叉树]]

#### 二叉树应用

##### 二叉搜索树

左子树<根<右子树

##### 平衡二叉树

平衡因子：二叉树中某结点的右子树高度与左子树高度之差

左单
右单
左右双旋：左孩子的右孩子
右左双旋：右孩子的左孩子

##### 堆与优先队列

最大堆：每个结点的值都大于等于其子结点（如果有的话）的值的树

##### 哈夫曼树

哈夫曼树常见的应用是在数据通信和数据压缩领域，经哈夫曼编码的信息消除了冗余数据，有效的提高了通信信道的传输效率

是一棵非完全二叉树
树中一定没有度为1的结点

树的带权路径长度是从根节点到叶子结点的带权路径
WPL是所有从根节点到叶子结点的带权路径之和

#### 树与森林

##### 将树转换为二叉树

1. 树中所有相邻兄弟结点之间加一条线
2. 对于树中的每个结点，只保留它与第一个孩子结点之间的连线，删去它与其他孩子结点之间的连线
3. 以树的根结点为轴心，将整棵树顺时针转动一定角度，使之结构层次分明

##### 将森林转换为二叉树

1. 将森林中的每棵树转换为相应的二叉树
2. 第一课二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树根结点的右孩子，当所有的二叉树连在一起后，所得到的二叉树就是由深林转换得到的二叉树

##### 二叉树还原为森林、树

1. 若某结点是其双亲的左孩子，则把该结点的右孩子、右孩子的右孩子……都与该节点的双亲结点用线连接起来
2. 删除掉原二叉树中所有双亲结点与右孩子结点的连线
3. 整理1 2 步所得到的树或森林，使之结构层次分明

##### 树和森林的遍历

###### 先根遍历 等价于转换二叉树的先序遍历

###### 后根遍历 等价于转换二叉树的中序遍历

##### 树的存储

1. 孩子表示法
	1. 定长结点的多重链表（存储空间浪费严重）
	2. 不定长结点的多重链表（结点结构不同，操作复杂）
2. 孩子兄弟表示法（二叉树表示法）
3. 双亲表示法
	用一组连续的存储单元储存树中的结点

---

## 图

#### 图的存储及基本操作

##### 图的邻接矩阵表示法

无权图：相连为1，不相连为0
有权图：相连为$W_i$（自己到自己为0），不相连为$\infty$ 

##### 图的邻接表表示法

对图中每个结点$v_i$建立一个单链表

#### 最小生成树

##### Prim算法

通过不断增加生成树的顶点来得到最小生成树，算法复杂度与图中边数无关，适用于边数比较稠密的图

##### Kruskal算法

令最小生成树的初始状态为只有n个孤立结点的非连通图，首先在E中选择权重最小的图，若该边所关联的两个顶点属于两个不同的联通分量，则将此边加入到T中，否则选择下一条权重最小的边
算法复杂度主要取决于边数，适用于构造稀疏图的最小生成树

#### 最短距离

##### [[Dijkstra]]算法

##### [[Floyd]]算法

#### 拓扑排列

一个简单的拓扑排序算法是先找出任意一个入度为0的顶点，然后输出该顶点，并从图中删除该顶点和由他指出的边，修正其余顶点的入度信息。然后对图中剩余部分用同样的方法处理。当图中找不到入度为0的结点时，如果所有的顶点已经访问完，则图中不存在环，否在存在环


#### 关键路径

在有向无环图中，可以用顶点表示事件，边表示活动，边的权值表示活动所需的时间，边的方向表示活动可以在起点事件之后开始，也可以在终点事件之前完成。这样的有向无环图也称AOE网。在AOE网中，只有一个入度为0的点（源点），只有一个出度为0的点（汇点）。

通常用AOE网来估算项目的完成时间，完成工程的最短时间是从源点到汇点的最长路径的长度，该路径称为<font color="#FF8C00">关键路径</font>，关键路径上的活动称为关键活动

$ve(v_i):$ 表示事件$v_i$ 的最早发生时间
$vl(v_i)$：表示事件$v_i$的最迟发生时间
$e(a_i)$ :表示活动$a_i$的最早开始时间
$l(a_i)$ :表示活动$a_i$的最迟开始时间

---

## 查找

存储在磁带上的顺序文件的查找只能用 顺序查找

#### 静态查找

##### 顺序表查找法
##### 折半查找法

查找前提是数据记录<font color="#FF8C00">有序</font>的存储在<font color="#FF8C00">线性</font>表中
```c++
int BiSearch(int *arr,int key,int n)
{
	int left=0,right=n-1;
	whhile(left<=right)
	{
		int mid=(left+right)/2;
		if(key>arr[mid])
			left=mid+1;
		else if(key<arr[mid])
			right=mid-1;
		else
			return mid;
	}
}
```
##### 分块查找（索引顺序查找）

首先将n个元素划分为m块，每一块中的元素不必有序，但块与块之间必须有序。对每个数据块建立一个索引项，形成具有m个索引项的索引表，索引项包括两项内容：块中的最大关键字（关键字项），该块中第一个记录的位置（指针项），索引表中各个索引项按照关键字有序

#### 动态查找

##### B-树（B树）

m阶B-树性质：
1. 树中每个结点至多有m棵子树
2. 根节点至少有两棵子树
3. 除根之外所有非叶子结点至少有$\lceil \frac m2\rceil$棵子树
4. 所有叶子结点都出现在同一层
5. k个关键字，k+1个指针

包含有n个关键字的m阶B-树的高度$h\leq log_{\lceil \frac m2 \rceil} \frac{n+1}{2}+1$ 

B-树的插入：
1. 关键字插入叶子结点后，叶子结点的关键字个数不超过m-1；
2. 插入关键字后叶子结点的关键字个数超过m-1，这时要分裂叶子结点，把中间的关键字提到双亲结点中
3. 插入关键字后B-树根节点的关键字个数超过m-1，这是要分裂根节点，将根节点中间的关键字提升到新建的根节点中，这是唯一会引起B-树高度增长的情形

B-树的删除
1. 被删关键字所在结点的关键字数目不小于$\lceil \frac m2 \rceil$,直接删
2. 被删关键字所在结点中关键字数目等于$\lceil \frac m2 \rceil-1$ ，而与该节点相邻的右兄弟（左兄弟）结点中的关键字大于$\lceil \frac m2 \rceil-1$，则需将其右兄弟结点中最小的关键字上移至双亲结点中，而将双亲结点中划分这两个结点的关键字下移至被删关键字所在结点中
3. 被删关键字所在结点和其相邻的兄弟结点中的关键字数目均等于$\lceil \frac m2 \rceil-1$，假设该结点有左兄弟，删除关键字后，将该结点中剩余的关键字和指针及双亲结点中划分该结点与其左兄弟的关键字一起，合并到左兄弟结点中，若没有左兄弟，则合并到右兄弟中
4. 删除后根结点孩子关键字不足，则合并根节点至另一孩子

##### B+树

m阶B+树性质
1. 每个结点至多有m棵子树
2. 根结点至多有两棵子树
3. 除根以外所有非叶子结点至少有$\lceil \frac m2 \rceil$棵子树
4. 所有叶子结点都出现在同一层
5. k个关键字，k个指针

#### 散列

散列方法就是在记录的关键字与它的存储位置之间建立一个确定的函数关系，使得每个关键字与结构中一个唯一的位置相对应。散列方法的核心是：由散列函数确定关键字与散列地址之间的对应关系，通过这种关系实现存储并进行查找

##### 冲突解决办法

###### 开放定址法

把所有的记录直接存储在散列表中

1. 线性探查法
将散列表看成一个环形表，设散列表长为m。若在初始探查地址d发生冲突，则依次探查地址单元$A_i=(d+i)\%m$ ,其中$0<i<m$ ,直到找到一个空闲地址。若沿着该探查地址序列探查一遍后，又回到了d，则意味着失败

`散列不同地址的不同结点争夺同一个后继散列地址的现象称为冲突的一次聚集或堆积`

2. 二次探查法

$A_i=(d+\pm i^2),i=1,2,\cdots$ 

3. 双散列探查法

$H_i=(Hash(key)+i*ReHash(key))\%m,i=0,1,2,\cdots,m-1$ 

最多经过m次探查就会遍历表中所有位置

###### 链接法（开散列法）

处理冲突简单，不会出现冲突的聚集现象，平均查找长度较短

###### 桶定址法

若某个地址关联的桶满了，则继续采用线性探查法解决冲突


---

## 排序

稳定的排序：直插，冒泡，归并，基数
不稳定的排序：希尔，直接选择，堆，快速

快速排序每趟都能选出一个元素放在最终位置上，并且其时间性能受数据初始特性影响

#### 插入排序

##### 直接插入排序
```c++
void InsertSort(int *Date,int n)
{
	int p,i;
	for(int p=1;p<n;p++)
	{
		int temp=Date[p];
		i=p-1;
		while(i>=0&&Date[i]>temp)
		{
			Date[i+1]=Date[i];
			i--;
		}
		Date[i+1]=temp;
	}
}
```
时间复杂度$O(n^2)$
算法稳定

##### 折半插入排序

```c++
void BinaryInsertSort(int *Date,int n)
{
	int left,mid,rihgt,p;
	for(p=1;p<n;p++)
	{
		int temp=Date[p];
		letf=0;
		right=p-1;
		while(left<=right)
		{
			mid=(left+right)/2;
			if(temp>Date[mid])
				left=mid+1;
			else
				rihgt=mid-1;
		}
		for(int i=p-1;i>=left;i--)
			Date[i+1]=Date[i];
		Date[left]=temp;
	}
}
```
节省查找时间，移动时间没变
算法稳定

##### 希尔排序

###### 增量折半的希尔排序
```c++
void ShellSort(int *Date,int n)
{
	int d=n/2;
	while(d>=1)
	{
		for(int k=0;k<d;k++)
		{
			for(int i=k+d;i<n;i+=d)
			{
				int temp=Date[i];
				int j=i-d;
				while(k>=0&&Date[j]>temp)
				{
					Date[j+1]=Date[j];
					j--;
				}
				Date[j+1]=temp;
			}
		}
		d/=2;
	}
}
```

保持增量互质可以有效提升希尔排序的效率

###### Knuth增量的希尔排序

$$d_1=1;d_{i+1}=3d_i+1$$

 算法不稳定


#### 交换排序

##### 冒泡排序

每次把最大值交换到最后面

算法稳定

##### 快速排序

分割策略
```c++
int Partion(int *Date,int left,int rihgt)
{
	int  pivot=Date[left];
	while(left<right)
	{
		while(left<right&&Date[rihgt]>pivot)
			rihgt--;
		Date[left]=Date[right];
		while(left<right&&Date[left]<=pivot)
			left++;
		Date[right]=Date[left];
	}
	Date[left]=pivot;
	return left;
}
```

快排
```c++
void QUickSort(int *Date,int left,int right)
{
	if(rihgt<=left)
		return ;
	int p=Partion(Date,left,right);
	QuickSort(Date,left,p-1);
	QuickSort(Date,p+1,right);
}
```
最坏时间复杂度$O(n^2)$,最好$O(nlogn)$ 
平均时间复杂度$O(nlogn)$ 

#### 选择排序

###### 简单选择排序

算法不稳定
运行时间与输入无关 ，比较次数与原始序列无关
数据交换最少

###### 堆排序

1. 将初始待排数据初始化为一个最大堆，初始化当前待排序序列的元素个数n
2. 将堆顶元素和当前最后一个元素进行交换，n--;
3. 调整堆结构
4. 如果当前待排序元素数n>1，则重复 2 3

#### 归并排序

1. 先把序列划分为长度基本相等的子序列
2. 对每个子序列归并排序
3. 把排好序的子序列合并为最后的结果

#### 基数排序

























