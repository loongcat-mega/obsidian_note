
## RISC

Reduced Instruction Set Computer  精简指令集计算机，是一种执行较少类型计算机指令的微处理器，
指令长度较短，运行速度比CICS快，指令系统相对简单，只要求硬件执行很有限但最常用的那部分指令，大部分复杂的操作则使用成熟的编译技术，由简单指令合成。在RISC中，计算机实际上<font color="#FF8C00">每一个机器周期都在执行指令</font>，无论简单或复杂的操作，均有简单指令的程序块完成，具有较强的仿真能力

采用精简的、<font color="#FF8C00">长度固定</font>的指令集，<font color="#FF8C00">指令数少，寻址方式少，指令格式少，拥有较大寄存器组</font>，不支持汇编语言，只有存数、取数指令访问存储器，其余指令操作均在寄存器之间进行，以<font color="#FF8C00">硬布线逻辑为主</font>，不用或少用微程序控制。

编译后指令长度长，内存需要较大


## 系统总线
#### 总线基本概念
1. 面向CPU的双总线结构没有系统总线
2. 面向CPU的单总线结构，CPU与主内没有线路连接
3. 以存储器为中心的双总线结构，CPU与主存之间有存储总线连接
	既提高了传输效率，又减轻了系统总线负担，还保留了I/O设备与存储器交换信息时不经过CPU的特点

#### 系统总线
##### 数据总线
	双向传输线，位数与机器字长、存储字长有关
##### 地址总线
	连接CPU与主存或I/O设备
	由CPU输出，单向传输
	位数与存储单元的个数有关
##### 控制总线
	单向传输，但总体双向
#### 通信总线
1. 同步通信
	优点：规定明确统一，模块间配合简单
	缺点：局限，缺乏灵活性
2. 异步通信
`采用应答方式`
	不互锁、半互锁、全互锁
3. 半同步
	插入等待周期，适用于整体速度不高，但各部分速度差异大的系统

#### 总线特性
###### 机械特性
###### 电气特性
	方向及电平范围
###### 功能特性
###### 时间特性
-
##### 总线性能指标
###### 总线宽度
	数据总线根数
###### 总线带宽
	总线传输速率
###### 总线复用

#### 总线控制
-
##### 总线判优控制
######  链式查询
	BS:总线忙; BR:总线请求; BG:总线同意
	优点：只需很少几根线就能按一定优先次序实现总线控制，很容易扩充设备
	缺点：对电路故障敏感，优先级低的设备很难获得请求，离总线控制部件越近优先级越高
###### 计数器定时查询
	无BG，加了一组设备地址线
	优点：设备优先级可根据计数器初始值改变，对电路故障不敏感`
	缺点：增加控制线数，控制复杂
###### 独立请求法
	每个设备均有BR和BG，总线控制部件内有排队器
	优点：响应快，优先次序控制灵活
	缺点：总线控制复杂
计数器查询设备线数：log<sub>2</sub>n
独立请求需要2n条线

---

## 存储器

<font color="#B22222">默认按字节寻址</font>

#### 存储器分类
###### 随机存储器（RAM）
	任何一个存储单元的内容都可以随机存取，且存取时间与存储单元的物理位置无关
###### 只读存储器（ROM）
	只能读不能写
	通常存放固定不变的程序、常数、和汉字字库，甚至操作系统固化。与RAM共同作为主存的一部分，统一构成主存的地址域
###### 串行访问存储器
	按其物理位置的先后顺序寻找地址，信息位置不同，读写时间不同

#### 存储器层次结构
CPU不能访问直接辅存，辅存只能与主存交换信息
###### 缓存-主存
	解决CPU和主存速度不匹配问题
	数据调动由硬件自动完成
###### 主存-辅存
	解决存储系统容量问题
	数据调动由硬件和操作系统共同完成 

#### 主存技术指标
###### 存储容量=存储单元个数 * 存储字长
###### 存储速度
###### 存储器带宽=宽度 * 频率
	提高存储器带宽
	1. 缩短存取周期
	2. 增加存储字长
	3. 增加存储体

#### 半导体存储芯片的译码驱动方式
###### 线选法
	用一根字选择线直接选中一个存储单元的各位
	结构简单，只适用于容量不大的存储芯片

###### 重合法
	行列存储矩阵分别选中，共同选中的那位才被选中


#### 随机存取存储器（RAM）
###### 静态RAM（SRAM）
`用触发器工作原理存储信息，即使信息读出后，仍保持原状态，但电源掉电时，原存储信息丢失，属于易失性存储器`
###### 动态RAM（DRAM）
`靠电容存储电荷原理寄存信息，即使电源不掉电，信息也会自动丢失。为此，必须在2ms内对其所有存储单元恢复一次原状态，称为再生或刷新`
#### 刷新
`将原信息读出，并重新写回的再生过程`
`采用定时刷新的方法，在一定时间内，对动态RAM的全部基本单元必做一次刷新，一般取2ms，称为刷新周期，刷新是一行行进行的`
###### 集中刷新
	在规定的一个刷新周期内，对全部存储单元集中一段时间逐行进行刷新，此刻必须停止读写操作，停止工作的时间称为死区
###### 分散刷新
	对每行存储单元的刷新分散到每个存取周期内完成
	使存取周期变长
###### 异步刷新
	2ms内对N行各刷新一遍，即每隔2ms/N刷新一行，每行刷新时间仍为一个存取周期
	既缩短死区时间，又充分利用最大刷新间隔为2ms的特点

#### 只读存储器（ROM）
######  掩模ROM
	制成后不能改变原状态
######  PROM
	实现一次性编程的只读存储器
###### EPROM
	可擦除可编程只读存储器，可做任意次修改
###### Flash Memory
	闪存

#### 存储器与CPU的连接
###### 位扩展
	增加存储字长
	8片16K * 1位的存储芯片连接，组成一个16K * 8位的芯片
######  字扩展
	增加存储字的数量
	2片1K * 8位的存储芯片可组成一个2K * 8位的芯片
######  字、位扩展
	既增加存储字数量，又增加存储字长

`不与存储器相连的地址线要控制`
片选+读写

#### 存储器的校验
`码距越大，纠错、检错能力越强`
`在信息编码中增加若干检测位，增加码距，就能增加纠错和检错能力`
C<sub>1</sub>: 1 3 5 7 9
C<sub>2</sub>: 2 3 6 7 10
C<sub>3</sub>: 4 5 6 7 12
C<sub>4</sub>: 8 9 10 11 12

#### 提高访存速度
###### 单体多字
一个存储体内多个存储字，增加了存储器带宽
###### 多体并行
1. 高位交叉编址
	高位表体号，低位表体内地址
2. 低位交叉编址
	低位表体号，高位表体内地址
在不改变每个模块存取周期的前提下，提高了存储器带宽

#### Cache
`CPU访存优先级低于IO`
`主存速度低于CPU`
`指令数据在主存内连续存放，并且可能会被多次调用`
每个缓存块需设一标记，用来表示当前存放的是内存中的哪一块

	命中率：CPU要访问的信息在已在cache中的比率

$h=\frac{N_c}{N_c+N_m}$

cache-主存系统平均访问时间
$t_a=ht_c+(1-h)t_m$

###### cache-主存地址映射
1. 直接映射

$i=j\quad mod\quad C$ 
$i:缓存块号$
$j:主存块号$
$C:缓存块数$

主存地址
| 主存字块标记 | cache字块标记 | 字块内地址 |
| ------------ | ------------- | ---------- |
| t位             | c位              | b位           |

2. 全相联映射

主存地址
| 主存字块标记 | 字块内地址 |
| ------------ | ---------- |
| m=t+c位             | b位           |

3. 组相联映射

$i=j\quad mod \quad Q$
$Q:组数，每组有R块$

主存地址
| 主存字块地址 | 组地址 | 组块内地址 |
| ------------ | ------ | ---------- |
| s=t+r位             |q=c-r位        | b位           |

读一个字，存一个字块
设主存容量为16MB，cache容量为8KB。每个字块内有8个字，每字32位。设计一个四路组相联映射的cache组织.设cache初始状态为空，CPU依次从主存的第$0,1,2,\cdots 99$号单元读出100个字（主存一次读出一个字），并重复此次序读10次，问命中率是多少？
$$\frac{100\times 10-13}{100\times 10}=0.987$$


###### 替换策略
1. 先进先出 FIFO
不能提高命中率
2. 近期最少使用 LRU
3. 随机

---


## 输入输出系统

#### 发展阶段
1. 早期阶段

I/O与主存交换信息必须经过CPU
I/O有独立的逻辑电路，且其逻辑控制器与CPU控制器构成整体，增删I/O困难

2. 接口模块与DMA阶段

I/O设备通过接口模块与主机相连
计算机系统采用总线结构

接口内数据通路功能：缓冲+变换；控制通路功能：传送控制信号
使多台设备分时占用总线
主存与I/O交换信息时，CPU中断现行程序

DMA：直接存储器存取
I/O与主存间有一条数据通路，I/O可与主存直接交换信息，CPU在I/O与主存交换信息时能继续完成自身工作

3. 具有通道结构的阶段

解决众多DMA接口同时访存的冲突
解决CPU对DMA管理问题

通道是用来负责管理I/O以及实现主存与I/O间信息交换的部件：有特殊功能的处理器
有专门的通道指令，根据CPU的I/O指令进行启动、停止或改变工作状态

依赖通道管理的I/O在与主存交换信息时，CPU不直接参与管理

4. 具有外围处理机的阶段

外围处理机基本独立于主机工作
主要进行I/O控制，码制转换，格式处理，数据块检错纠错等


#### 输入输出系统的组成

1. I/O软件

I/O指令：
	CPU指令系统的一部分
| 操作码 | 命令码 | 设备码 |
| ------ | ------ | ------ |

通道指令：
	通道自身的指令
	有通道结构的I/O中，I/O指令完成启停I/O、查询I/O通道状态，及控制通道

2. I/O硬件

	一个设备控制器可控制若干同类型的I/O

#### I/O与主机的联系方式

1. I/O编码方式
	统一编址：将I/O设备码看成存储器地址的一部分
	不统一编制：所有对I/O的访问必须有专门的I/O指令
当I/O通过接口与主机相连时，CPU可通过访问接口地址来访问I/O

2. 设备寻址
3. 传送方式
4. 联络方式
	异步工作采用应答信号联络
	同步工作采用同步时标联络，要求I/O与CPU工作速度同步

5. I/O与主机连接方式
	辐射式
	总线式

### 程序查询方式

`CPU通过程序不断查询I/O是否做好准备，要求I/O接口内置一个能反映I/O设备是否已准备就绪的状态标记`
此时I/O和CPU处于串行工作状态

### 程序中断方式

`CPU在启动I/O后，不查询I/O，继续执行自身程序，只是当I/O准备就绪并向CPU发出中断请求后才予以响应`
此时I/O准备和CPU执行程序同时进行

	硬件：增加电路
	软件：编制中断服务程序

提高计算机整体效率，应对突发事件，实时控制

在I/O：

	中断请求触发器：INTR  =1 提出中断请求
	中断屏蔽触发器：MASK  =0 未被屏蔽

任何一个瞬间只能接受一个中断源的请求
$多个中断源同时请求 \Longrightarrow {排队器 }$  

排队器：
速度越高的I/O，优先级越高

设备编码器（中断向量地址形成部件）
通过向量地址来寻找设备的中断服务程序入口地址，中断向量地址由硬件产生

##### I/O中断处理流程

###### CPU响应中断的条件和时间：

	CPU中允许中断触发器 ENINT  =1
	CPU在每条指令执行周期结束后，向接口发送中断查询信号及获取I/O中断请求

###### I/O中断处理过程

当CPU通过I/O指令的地址码选中设备

1. CPU发启动I/O设备命令，将接口中B置1，D置0；
2. 接口启动设备工作
3. 输入设备将数据送入数据缓冲寄存器
4. 输入设备向接口发出工作结束命令，将D置1，B置0，标志设备准备就绪
5. 当D=1，MASK=0时，指令执行周期结束后，由CPU发出中断查询信号
6. 设备INTR置1，即设备已向CPU提出<font color="#FF8C00">中断请求</font>，同时INTR送至排队器进行<font color="#FF8C00">中断判优</font>
7. 若EINT=1，设备又被排队器选中，即进入<font color="#FF8C00">中断响应</font>阶段，由中断响应信号INTR将排队器输出送至设备编码器形成向量地址
8. 向量地址送至PC，作为下一条指令地址
9. 指令执行结束后，跳转至设备的服务程序入口，开始执行中断服务程序，进入<font color="#FF8C00">中断服务</font>阶段，通过输入指令将数据缓存寄存器的输入数据送至CPU通用寄存器，再进入主存相关单元
10. 中断服务程序的最后一条指令是<font color="#FF8C00">中断返回</font>指令，当其执行结束时，即中断返回原程序断点处，至此一个完整的中断处理过程结束

###### 中断服务流程

1. 保护现场

	保存程序断点   由中断引指令完成
	保存通用寄存器和状态寄存器内容  由中断服务程序完成

1. 中断服务
2. 恢复现场
3. 中断服务
4. 中断返回

单重中断： 关中断  保存断点 保护现场 中断处理 恢复现场 开中断 中断返回
多重中断：关中断  保存断点 保护现场  开中断 中断处理 恢复现场 中断返回

CPU在处理中断服务程序时仍需暂停原程序的运行

#### DMA方法

I/O直接与主存交换信息而不经过CPU

DMA与CPU同时访存，CPU总是将总线占有权让给DMA，称为周期挪用、周期窃取

在DMA窃取存取周期时，CPU尚能继续执行内部操作，相比于中断，省去保护现场和恢复现场

高速I/O设备若每次申请与主机交换信息时，都要等待CPU做出中断响应后再进行，很可能会使数据丢失

###### 周期挪用

每当I/O设备发出DMA请求时，I/O设备便挪用总线占用权一个或几个主存周期

适合I/O设备读写周期大于主存周期的情况

###### DMA工作过程

1. 预处理

给DMA逻辑控制器指明数据传送方向
向DMA设备地址寄存器送入设备号，并启动设备
向DMA主存地址寄存器送入交换数据的主存起始地址
送入交换数据的个数

2. 数据传送

以数据块为单位传送

3. 后处理

当DMA的中断请求得到响应后，CPU执行中断服务程

传送一个字符需要一个主存存取周期


---

## 计算机中的运算方法

#### 无符号数和有符号数
##### 无符号数

计算机中的数均存放在寄存器中，通常称寄存器的位数为机器字长

##### 有符号数
1. 原码表示
2. 补码表示
3. 反码表示
4. 移码表示（补码符号位取反）

#### 定点数和浮点数
##### 定点数
##### 浮点数
$$N=S\times r^j$$
S：尾数
r：基数
j：阶码

在计算机中规定浮点数的尾数用纯小数形式，将尾数最高位为1的浮点数称为规格化数。浮点数表示成规格化形式后，其精度最高

###### 浮点数的规格化

尾数左移一位，阶码减1，称为左规
尾数右移一位，阶码加1，称为右规

一般基数r越大，可表示的浮点数数范围越大，但浮点数精度下降
![[Pasted image 20221225123750.png]]

#### 定点运算

##### 移位运算

###### 算术移位规则

1. 正数：添0
2. 负数
	1. 原码：添0
	2. 反码：添1
	3. 补码：左移添0，右移添1

负数补码左移时，高位丢0，结果出错；低位丢1，影响精度

##### 加法与减法运算

$$A-B=A+(-B)$$
补码表示的两个数在进行加法运算时，可以把符号位与数值位同等处理，只要结果不超出机器能表示的数值范围，运算结果按$2^{n+1}$ 取模或对2取模，就能得到运算结果

###### 溢出判断

1. 用一位符号判断溢出
无论是加法还是减法，只要实际参加操作的两个数符号相同，结果又与原操作数符号不同，即为溢出

2. 用两位符号判断溢出
用符号位产生的进位与最高有效位产生的进位异或，相异为1，表溢出，否则没有溢出

无论是否发生溢出，高位（第一位）符号位永远代表真正的符号

采用双符号位方案时，寄存器或主存中的操作数只需要保存一位符号位即可

##### 乘法运算

###### 原码一位乘

1. 乘积的符号位由两原码符号位异或运算结果决定
2. 乘积的数值部分由两数绝对值相乘

###### 原码两位乘

运算中右移两位的操作按照补码右移规则完成

只有对部分积取三位符号位，且以最高符号位作为真正的符号位，才能保证运算正确

当乘数位数为偶数时，需在乘数的最高位前增加两个零

当乘数为偶数时，需要做n/2次移位，最多做n/2+1次加法
当乘数为奇数时，乘数最高位前可只增加一个0，需要做n/2+1次移位，最多做n/2+1次加法

###### 补码一位乘

部分积采用双符号位

1. 被乘数x符号任意，乘数y符号为正
$$[x*y]_补=[x]_补*y$$
此时按照原码乘法规则来

2. 被乘数x符号任意，乘数符y为负
$$[x*y]_补=[x]_补*(y*)+[-x]_补$$
矫正法

3. 被乘数x和乘数y符号任意（Booth法）

符号位一并参与运算，部分积取双符号位，按补码规则移位
新增一个附加位$y_{n+1}$ ,初始$y_{n+1}=0$，最后一步不移位（移n次）

##### 除法运算

###### 加减交替法

当$R_i>0$,商上1，做$2R_i-y^*$
当$R_i<0$,商上0，做$2R_i+y^*$

#### 浮点四则运算

##### 浮点加减运算

1. 对阶，使两数的小数点位置对齐
2. 尾数求和，将对阶后的两尾数按定点加减运算规则求和
3. 规格化，为增加有效数字的位数，提高运算精度，必须将求和后的尾数规格化
4. 舍入，为提高精度，要考虑尾数右移时丢失的数值位
5. 溢出判断，判断结果是否溢出

###### 对阶
先求出阶码差，按小阶码向大阶码看齐的原则，使小阶码的尾数向右移位。尾数右移时可能会发生数码丢失，影响精度

###### 尾数求和
###### 规格化

当$S>0$时，补码规格化为$$[S]_补=00.1\cdots$$
当$S<0$时，补码规格化我$$[S]_补=11.0\cdots$$
若运算结果两位符号位不等，表示尾数之和绝对值大于1，需右规

###### 舍入

1. 0舍1入法
2. 恒置1法

###### 溢出判断

看阶符是否一致，相异表溢出


##### 浮点数乘除运算

乘法：
1. 阶码相加
$$[j_x+j_y]_移=[j_x]_移+[j_y]_补$$
2. 尾数相乘



---


## 指令系统

#### 机器指令

每一条机器语言的语句称为机器指令

#### 指令的一般格式

指令由操作吗和地址码组成

1. 操作码

指明该指令所要完成的操作，其位数反映了机器的操作种类，即机器允许的指令条数

操作码长度可以是固定的，也可以是变化的。前者将操作码集中放在指令的一个字段内，便于硬件设计，编译时间短，适用于字长较长，大中型计算机及RISC中
变长操作码采用扩展操作码技术，有效压缩操作码平均长度，译码分析难度增加，适用于字长较短的计算机

2. 地址码

用来指出该指令的源操作数的地址、结果的地址以及下一条指令的地址
这里的地址可以是主存的地址，也可以是寄存器的地址，甚至可以是I/O设备的地址


四指令地址：四次访存 取址一次 取操作数两次 存结果一次
| OP  | $A_1$ | $A_2$ | $A_3$ | $A_4$ |
| --- | ----- | ----- | ----- | ----- |
|    | 第一操作数地址      | 第二操作数地址      | 结果地址      |  下一条指令地址     |

$A_1 (OP) A_2\rightarrow A_3$

	省去A4,由PC自动加1，变三指令地址

三指令地址：四次访存 
| OP  | $A_1$ | $A_2$ | $A_3$ |
| --- | ----- | ----- | ----- | 
|     | 第一操作数地址      | 第二操作数地址      | 结果地址      |  
$A_1 (OP) A_2\rightarrow A_3$

	省去A3，结果暂存在ACC，变二指令地址

二指令地址：四次访存
| OP  | $A_1$          | $A_2$          |
| --- | -------------- | -------------- |
|     | 第一操作数地址 | 第二操作数地址 |
$A_1 (OP) A_2\rightarrow A_1$

	若使最终结果暂存在ACC中，变为三次访存

一地址指令：两次访存
| OP  | $A_1$          |
| --- | -------------- |
|     | 第一操作数地址 |
$ACC (OP) A_1\rightarrow ACC$

零地址指令

	NOP HLT（停机指令） 只有操作码
	RET IRET（中断返回） 操作数地址隐含在堆栈指针中

`采用操作码扩展技术，操作码位数可变，若二地址、一地址、零地址的操作码长度分别为4位、10位、16位。则二地址指令操作码每减少一种，就可多构成2^6种一地址指令，一地址指令操作码每减少一种，就可多构成2^6种零地址指令`


###### 边界对齐

字节数据任意存放,半字存放在末一位地址为0处，字存放在末两位地址为0处，双字地址放在末三位地址为0处

#### 寻址方式

###### 指令寻址

顺序寻址：通过程序计数器加1，自动形成下一条指令地址
跳跃寻址：通过转移类指令实现

###### 数据寻址

在指令字中必须设一字段来指明属于哪一种寻址方式
指令的地址码字段通常都不代表操作数的真实地址，把它称为形式地址，记为A
操作数的真实地址称为有效地址，记为EA

1. 立即寻址

操作数本身设在指令字内，即形式地址不是操作数的地址，而是操作数本身，又称为立即数，数据采用补码形式存放
| OP  | #   | A |
| --- | --- | --- |


该类型指令在执行阶段不必再访问存储器。

2. 直接寻址

指令字中的形式地址就是操作数的真实地址

寻找操作数简单，指令执行阶段只访存一次。

3. 隐含寻址

指令字中不明显地给出操作数的地址，其操作数的地址隐含在操作码或某个寄存器中

4. 间接寻址

指令字中的形式地址不直接给出操作数的地址，而是指出操作数有效地址所在的存储单元

与直接寻址相比，扩大了操作数的寻址范围

缺点：指令的执行阶段需要访存两次或多次，致使指令执行时间延长

5. 寄存器寻址

| OP  | 寻址特征 | $R_i$ |
| --- | -------- | ----- |


地址码直接给出了寄存器的编号

指令执行阶段无需访存，指令字较短，节省了存储空间

6. 寄存器间接寻址

$R_i$中的内容不是操作数，而是操作数所在主存单元的地址号

与寄存器寻址相比，指令执行阶段还需访问主存，因此有效地址不是存放在存储单元中，而是存放在寄存器中，比间接寻址少访存一次

7. 基址寻址


基址寻址设有基址寄存器BR，其操作数有效地址EA等于指令字中的形式地址与基址地址寄存器中的内容之和
$$EA=A+(BR)$$
基址寻址可以扩大操作数的寻址范围，基址寄存器的位数可以大于形式地址A的位数

采用基址寻址可实现对主存空间的更大范围寻址


8. 变址寻址

有效地址EA等于指令字中的形式地址A与变址寄存器IX的内容之和
$$EA=A+(IX)$$


`基址寻址主要用于为程序或数据分配存储空间，故基址寄存器的内容常常由操作系统或管理程序确定，在程序执行过程中其值是不可变的，而指令字的A是可变的。`

`变址寻址主要用于处理数组问题，在数组处理过程中，可设定A为数组首地址，不断改变变址寄存器IX的内容，便可形成数组中任意数据的地址`

9. 相对寻址

有效地址是将PC中的内容与指令字中的形式地址A相加而成
$$EA=(PC)+A$$
10. 堆栈寻址


#### 指令格式设计


---

## CPU的结构和功能


CPU包括控制器（ALU）、运算器（CU）、寄存器和中断系统四大部分

控制器负责协调控制计算机各部件执行程序的指令序列，基本功能包括取指令、分析指令、执行指令

#### CPU的寄存器

###### 用户可见寄存器
1. 通用寄存器
可用于存放操作数，也可作为满足某种寻址方式所需的寄存器。如基址寻址寄存器、变址寻址寄存器、堆栈寻址所需的栈指针
2. 数据寄存器
3. 地址寄存器
4. 条件码寄存器

###### 控制和状态寄存器

MAR：存储器地址寄存器，用于存放将被访问的的存储单元地址
MDR：存储器数据寄存器，用于存放欲存入存储器中的数据或最近从存储器读出的数据
PC：程序计数器，存放现行指令地址，具有计数功能
IR：指令寄存器，存放当前欲执行的指令

ALU必须可直接访问MDR和用户可见寄存器


#### 指令周期

CPU每取出并执行一条指令所需要的全部时间称为指令周期
指令执行的每个阶段称为一个机器周期
指令周期、机器周期、时钟周期组成多级（三级）时序系统

```mermaid
graph LR
取址-->间址
间址-->执行
执行-->中断
中断-->下一周期
```

四个周期都有访存操作
取址：取指令
间址：取有效地址
执行：取操作数
中断：保存程序断点

#### 指令周期的数据流

#### 指令流水

m级流水线

###### 影响流水线性能的因素

结构相关：当多条指令进入流水线后，硬件资源满足不了指令重叠执行的要求产生的
数据相关：指令在流水线中重叠执行时，当后继指令需要用到前面指令的执行结果时发生的
控制相关：当流水线遇到分支指令和其他改变PC的值的指令时引起的

###### 流水线性能

1. 吞吐率：单位时间内流水线所完成指令或输出结果的数量

最大吞吐率 $T_{pmax}=\frac{1}{\Delta t}$

$\Delta t$ :m级流水线各段时间

实际吞吐率 $T_p=\frac{n}{m\Delta t+(n-1)\Delta t}$

2. 加速比

m段流水线与等功能的非流水线的速度之比

$S_p=\frac{m}{1+(m-1)n}$


3. 效率

$E=\frac{S_p}{m}=T_p\Delta t$

流水线中的多发技术

1. 超标量技术
2. 超流水技术
3. 超长指令字技术

---

## 控制单元的功能

#### 微操作命令分析

###### 取指周期

1. 现行指令地址送至存储器地址寄存器，记作$PC\rightarrow MAR$
2. 向主存发送读命令，启动主存读操作，记作$1\rightarrow R$
3. 将MAR所指的主存单元中的内容经数据总线读至MDR内，记作$M(MAR)\rightarrow MDR$
4. 将MDR中的内容送至IR，记作$MDR\rightarrow IR$
5. 指令的操作码送至CU译码，记作$OP(IR)\rightarrow CU$
6. 形成下一条指令的地址，记作$(PC)+1\rightarrow PC$

###### 间址周期

完成取操作数有效地址的任务

1. 将指令的地址码部分送至存储器地址寄存器，记作$Ad(IR)\rightarrow MAR$
2. 向主存发出读命令，启动主存读操作，记作$1\rightarrow R$
3. 将MAR所指的主存单元的内容经数据总线读至MDR，记作$M(MAR)\rightarrow MDR$
4. 将有效地址送至指令寄存器的地址字段，记作$MDR\rightarrow Ad(IR)$

###### 执行周期

取数指令：将主存X地址单元的内容读至累加器ACC中
$LDA\quad X$
1. 将指令的地址码部分送至存储器地址寄存器，记作$Ad(IR)\rightarrow MAR$
2. 向主存发出读命令，启动主存读操作，记作$1\rightarrow R$
3. 将MAR所指的主存单元的内容经数据总线读至MDR内，记作$M(MAR)\rightarrow MDR$
4. 将MDR的内容送至ACC，记作$MDR\rightarrow ACC$

存数指令:将累加器ACC的内容存于主存的X地址单元中
$STA\quad X$
1. 将指令的地址码部分送至存储器地址寄存器，记作$Ad(IR)\rightarrow MAR$
2. 向主存发出写命令，启动主存写操作，记作$1\rightarrow W$
3. 将累加器ACC内容送至MDR，记作$ACC\rightarrow MDR$
4. 将MDR中的内容写入到MAR所指的主存单元中，记作$MDR\rightarrow M(MAR)$

###### 中断周期

在执行结束时刻，CPU要查询是否有请求中断的事件发生，如果有则进入中断周期

1. 将特定地址"0"送至存储器地址寄存器，记作$0\rightarrow MAR$
2. 向主存发送写命令，启动存储器写操作，记作$1\rightarrow W$
3. 将PC的内容（程序断点）送至MDR，记作$PC\rightarrow MDR$
4. 将MDR中的内容（程序断点）通过数据总线写入到MAR所指的主存单元（0地址单元）中去，记作$MDR\rightarrow M(MAR)$
5. 将向量地址形成部件的输出送至PC，记作$向量地址\rightarrow PC$ ,为下一条指令的取指周期做准备
6. 关中断,将允许终端触发器清零,记作$0\rightarrow EINT$ 


#### 控制单元的外特性

###### 输入信号
1. 时钟
	完成每个操作都需要一定时间
	各个操作是有一定先后顺序、一定的节奏发出各个控制信号，控制单元必须受时钟控制，即每一个时钟脉冲使控制单元发送一个操作命令

2. 指令寄存器
3. 标志
4. 来自系统总线的控制信号

###### 输出信号

 1. CPU内的控制信号
 2. 送至系统总线的信号


![[Pasted image 20221223123124.png]]
![[Pasted image 20221223123239.png]]
![[Pasted image 20221223123854.png]]
![[Pasted image 20221223124158.png]]
![[Pasted image 20221223124233.png]]
![[Pasted image 20221223124339.png]]
![[Pasted image 20221223143449.png]]
![[Pasted image 20221223144000.png]]
![[Pasted image 20221223144142.png]]
![[Pasted image 20221223144414.png]]
![[Pasted image 20221223144631.png]]
![[Pasted image 20221223224739.png]]
![[Pasted image 20221225131008.png]]
![[Pasted image 20221225131543.png]]
![[Pasted image 20221225132608.png]]

