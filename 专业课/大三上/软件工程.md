
**软件工程三个要素：方法、工具和过程**

## 软件开发过程

软件开发又叫软件开发生命周期 SDLC
- 软件定义
- 软件开发
- 运行维护


- 可行性分析
- 需求分析
- 软件设计
- 程序编码
- 软件测试
- 软件维护

传统生命周期模型：顺序的将生命周期阶段组织起来
- 瀑布模型
    - 阶段间具有顺序性和依赖性，文档驱动，静态
    - 推迟实现，不急于编写代码
    - 质量保证
    - 不希望有变化，
- 原型模型
    - 用户与开发者之间的“桥梁”
    - 快速构建软件原型
    - 技术和工具不一定是实际项目需要的
- 增量模型
    - 把软件产品作为一系列增量构件来设计、编码、集成和测试
    - 每个构件由多个相互作用的模块构成，并且能够完成特定功能
    - 第一个增量构件提供核心功能
- 螺旋模型
    - 风险驱动
- 喷泉模型
    - 迭代和无缝
    - 线性过程作为总目标


敏捷软件开发：迭代开发 增量交付，精确+质量+速度+高效的自我管理团队
- XP
    - 降低需求变化的成本，注重实现
    - 小规模，短迭代周期
    - 测试驱动开发
    - 结对编程
    - 持续集成
    - 每日战力会议
- Scrum
    - 注重软件开发过程
    - 需求-->需求产品积压
    - 冲刺周期
    - Scrum核心工件：产品订单+冲刺订单+燃尽图
    - Scrum角色：产品拥有者+利益相关者+专家+团队成员
    - Scrum活动：计划会+每日立会+评审会+反思会
- DevOps
    - 强调了个体和交流胜过流程和工具
    - 核心目标：自动化+可持续交付
    - 高度依赖工具




## 需求分析


用户需求v系统需求

涉众：
- 最终用户-->直接涉众
- 投资者
- 业务提出者
- 业务管理者
- 业务执行者
- 其他涉众

用例：一种交互的方式来描述系统的场景，"捕获"用户需求，动态的

## 软件架构的构建

软件架构设计就是建立系统所需的数据结构和程序构件
- 体系结构风格
- 组成构件的结构和属性
- 构件间相互关系

4+1视图模型：
- 逻辑视图
- 开发视图
- 进程视图
- 物理视图
- 场景视图

软件架构基本元素：
- 构件
    - 具有某种功能的可重用的软件模版单元
- 连接件
    - 如管道、过程调用等
- 配置
    - 构件和连接件的拓扑逻辑和约束







## 类的分析与设计

类的分析与设计的目的是将需求阶段得到的信息加以整理和归纳，以开发者的视角抽象出相对稳定的静态结构。





## 设计优化

高质量的建模要以简单和小为基本观点

小规模设计师设计优化的基础，两个一般性原则：
- KISS Keepit simple stupid 尽可能简单
- YAGNI you ain't Gonna Need it  你不会需要他，不应过多考虑理论需求

Smell 缺陷：僵化性、脆弱性、顽固性、粘滞性、不必要的复杂、不必要的重复、晦涩性

### 设计优化的思想

运行时的多态：多态性在结构上形成类的继承层次。重写要求：细节调整，子类条件限制比父类宽松

耦合的消息链：交互集中的设计与交互分散的设计

![image.png](https://yaaame-1317851743.cos.ap-beijing.myqcloud.com/undefinedPasted%20image%2020231121223507.png)


狎昵关系：两个类表现的过分亲密，即高耦合

![image.png](https://yaaame-1317851743.cos.ap-beijing.myqcloud.com/undefinedPasted%20image%2020231121223934.png)


被拒绝的遗赠：对类进行需求的扩展，一是继承，二是委托(聚合/关联)

循环依赖：两个类分别处于不同的包中，并且具有双向导航的关联关系。引用接口类消除循环依赖

![image.png](https://yaaame-1317851743.cos.ap-beijing.myqcloud.com/undefinedPasted%20image%2020231121224256.png)


### 设计原则

接口隔离原则 ISP ：
- 尽量使用接口继承，而不是实现继承
- 接口在这里充当类的视图

好处：当业务需求发生变化时，更容易发生变化的是具体类，而这些变更可以通过稳定的抽象类进行隔离，提高了系统的可维护性

![image.png](https://yaaame-1317851743.cos.ap-beijing.myqcloud.com/undefinedPasted%20image%2020231121231642.png)





依赖倒置原则 DIP ： 依赖于抽象，而不是依赖于具体

![image.png](https://yaaame-1317851743.cos.ap-beijing.myqcloud.com/undefinedPasted%20image%2020231121231940.png)

开放封闭原则 OCP ：模块对于一个扩展应该是开放的，对于修改则是封闭的，这条原则是面向对象的最高境界、
- 模块的行为可以被扩展
- 模块的源代码不需要进行修改

OCP是相对的，没有绝对的OCP设计

![image.png](https://yaaame-1317851743.cos.ap-beijing.myqcloud.com/undefinedPasted%20image%2020231121232228.png)
![image.png](https://yaaame-1317851743.cos.ap-beijing.myqcloud.com/undefinedPasted%20image%2020231121232240.png)


Liskov原则 LSP ： 任何出现父类的地方都应该能使用子类对其进行无条件的替换

单一职责原则 SRP ： 设计类的功能应该只有一个

合成/聚合复用原则 CARP： 委托/聚合

#### 设计模式

提供了相似的程序设计任务中经常出现的相同问题的解决方案。一种在设计层次上的重用机制。一方面，模式针对的是抽象的设计思想的重用，而非代码的物理重用，另一方面，模式并不对具体问题提供完整的解决方案，而是提供方案的一种结构

三类设计模式：
- 创建模式 : 抽象工厂模式 单例模式
- 结构模式 : 适配器模式 桥模式 装饰模式 门面模式 代理模式
- 行为模式 : 观察者模式 策略模式 状态模式 

抽象工厂模式：解耦客户类在创建产品时引入的耦合

![image.png](https://yaaame-1317851743.cos.ap-beijing.myqcloud.com/undefinedPasted%20image%2020231130191153.png)


单例模式：在系统中只有一个实例，并且不允许生成其他副本

- 单例模式类的所有所有构造方法都是私有的，防止被外部创建
- 提供一个公有的静态方法获取该类的实例
- 类的实例变量为私有的或者受保护的

适配器模式：把一个类的接口变换成客户类所期待的另一种接口，从而使原本因接口原因不匹配而无法一起工作的两个类能够一起工作。实现：委托/继承


![image.png](https://yaaame-1317851743.cos.ap-beijing.myqcloud.com/undefinedPasted%20image%2020231130191623.png)![image.png](https://yaaame-1317851743.cos.ap-beijing.myqcloud.com/undefinedPasted%20image%2020231130191631.png)

桥模式：将抽象与实现分离

![image.png](https://yaaame-1317851743.cos.ap-beijing.myqcloud.com/undefinedPasted%20image%2020231130191902.png)






......

代理模式：一般用于对稀缺资源的管理，如数据库的连接等，目的是提高这些资源的利用率或者系统性能。为这些资源对象提供一个代理对象，并由代理对象控制对资源的使用，起到中介的作用

![image.png](https://yaaame-1317851743.cos.ap-beijing.myqcloud.com/undefinedPasted%20image%2020231130192228.png)


观察者模式：定义一种一对多的依赖关系，让多个观察者同时监听一个主题对象，观察者相对于MVC中的视图

![image.png](https://yaaame-1317851743.cos.ap-beijing.myqcloud.com/undefinedPasted%20image%2020231130192437.png)





## 软件测试

- 质量保证：产品保证与过程保证
- 形式化验证方法
- 等价类分析与基于控制流的测试
- 断言机制和测试框架是两种基本的测试实现技术


穷举测试不可行
停机问题不可解

- 白盒测试：被测对象的内部构成细节，如算法的结构和流程，多在类测试阶段使用
- 灰盒测试：集成测试阶段使用，关注类、包程序单元之间的关系
- 黑盒测试：测试系统外部行为

测试用例库
增量式开发 迭代测试--> 回归测试

界面测试:等价类方法，采用捕捉回放工具

McCabe指标度量方法复杂程度
LCOM* 指标度量类的内聚性

- 语句覆盖：经过的测试节点数与所有的节点数的比例
- 分支覆盖：测试经过的边数与所有边数的比例，分支覆盖无法保证理论上所有可能的程序逻辑都会被测试到
- 条件覆盖：原子谓词正反都要取到，条件覆盖与分支覆盖没有任何特别的联系，这表示分支的完全覆盖不能保证条件的完全覆盖，条件的完全覆盖也不能保证分支的完全覆盖
- 多条件组合覆盖，所有的覆盖要求在多条件组合覆盖标准中得到了综合
- 路径覆盖：度量一个方法中所有可能路径的覆盖情况，从McCabe导出程序基本路径集合中的独立路径条数


- 断言
- JUnit



## 软件项目级管理

- 项目级管理
    - 软件配置级管理
    - 软件项目管理
    - 软件质量保证
    - 风险管理
    - 人员沟通管理
- 组织级管理


软件配置管理：
- 版本管理  --> 核心
    - 对项目软件或项目文档的管理--> 核心
    - 已由工作不覆盖
    - 基于最新版本工作
- 发布管理
    - release
- 变更管理
- 构建管理
    - make

软件规模估算
- WBS (Work Breakdown Structure) 工作分解结构
- 功能点分析
    - 5种任务类型
    - FP=UFP* TCF(TCF=D1/100+0.7)

开发成本估算
- 经验曲线
- CoCoMo模型(Constructive Cost Model)
    - 提供工作量的估算


挣值分析
是对项目实施的进度、成本状态进行绩效评估的有效方法
挣值：到目前为止项目实际完成的价值

- BCWS:到目前为止的总预算成本，或到目前为止本应该应该完成的工作是多少
- ACWP:已完成工作的实际成本
- BCWP:挣值，到目前为止已经完成工作的预算成本
- BAC:预计总成本

- SV:进度偏差，>0超前
- CV:成本偏差，>0低于预算
- SPI:进度执行指标，>1超前
- CPI:成本执行指标，>1低于预算

- 50/50 原则：开始即50%
- 0/100 原则

质量管理TQM


软件质量保证SQA