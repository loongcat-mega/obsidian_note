![image.png](https://yaaame-1317851743.cos.ap-beijing.myqcloud.com/undefinedPasted%20image%2020230311093426.png)

## 进程


##### 子进程与父进程之间的全局变量共享？？


概念：程序的一次执行过程
区分进程：进程被创建时，操作系统会为该进程分配一个唯一的、不重复的PID Process ID

操作系统要记录PID、进程所属ID、给进程分配了哪些资源、进程的运行情况，这些信息都被保存在一个数据结构PCB 即进程控制块中

###### PCB是进程存在的唯一标志，进程创建时创建PCB，进程结束时回收PCB

进程实体由PCB、程序段和数据段组成

进程的特性：动态性、并发性、独立性、异步性、结构性

### 进程状态

创建态、就绪态、运行态、阻塞态、终止态

进程运行的过程中，可能会请求等待某个事件的发生，在这个事件发生之前，进程无法继续往下执行，此时进入阻塞态（主动行为）

一个进程可以执行exit系统调用，请求操作系统终止该进程

![image.png](https://yaaame-1317851743.cos.ap-beijing.myqcloud.com/undefinedPasted%20image%2020230421152928.png)

###### 进程三种基本状态：运行态、就绪态、阻塞态

![image.png](https://yaaame-1317851743.cos.ap-beijing.myqcloud.com/undefinedPasted%20image%2020230518100422.png)

### 进程控制

实现进程间的状态转换（用原语实现）

原语是操作系统一种特殊的程序，它的执行具有原子性，即这段程序运行必须一气呵成，不可中断

相关原语：
- 进程的创建
- 进程的终止
- 进程的阻塞和唤醒
- 进程的切换

进程并发执行的关键：PCB中进程运行环境的保存与恢复

### 进程间通信 IPC

两个进程间产生数据交互

###### 进程间通信需要操作系统支持

进程是分配系统资源的单位，因此各进程拥有的的内存地址空间相互独立

为了保证安全，一个进程不能直接访问另一个进程的地址空间

#### 共享内存

通过增加表项可将同一片共享内存区映射到各个进程的地址空间中

	基于存储区的共享 在内存中划出一块共享内存去 速度快，是高级通信方式
	基于数据结构的共享 速度慢，限制多 是低级通信方式

#### 消息传递

进程间的数据交换以格式化的消息为单位。进程通过操作系统提供的“发送消息/接收消息”两个原语进行数据交换

- 消息头
	- 发送进程ID
	- 接受进程ID
	- 消息长度等
- 消息体

	直接通信 发送方指明接收的进程 接收方指明要从哪个发送方接收
	间接通信 发送方和接收方指明哪个目标信箱

#### 管道通信

管道是一个特殊的共享文件，pipe文件。本质实在内存中开辟一个大小固定的内存缓冲区 具有先进先出的特性

半双工通信 只能单向通信

当管道写满后，写进程将进入阻塞状态。当管道为空时，读进程将进入阻塞状态
 

## 线程

有的进程需要“同时”做很多事（并行），而传统的进程只能串行的执行一系列程序，为此，引入线程，增加并发度

###### 线程是基本的CPU单元 也是程序执行流的最小单位

每个线程都有自己的堆栈和寄存器空间

进程间可并发，进程内的各线程间也可以并发

引入线程后，进程只作为除CPU之外的系统资源的分配单元。进程间切换系统开销大，同一进程内线程切换系统开销

![image.png](https://yaaame-1317851743.cos.ap-beijing.myqcloud.com/undefinedPasted%20image%2020230421222118.png)

#### 多线程模型

###### 操作系统只“看得见”内核级线程，因此只有内核级线程才是处理机分配的单位

##### 一对一模型

一个用户级线程映射到一个内核级线程。

优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并发执行

缺点：一个用户进程会占用多个内核级线程，变态成本高

##### 多对一模型

多个用户级线程映射到一个内核级线程，且一个进程只被分配一个内核级线程

优点：变态成本低

缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行



##### 多对多模型

克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户级进程占用太多内核级线程，开销太大的缺点

![image.png](https://yaaame-1317851743.cos.ap-beijing.myqcloud.com/undefinedPasted%20image%2020230518101201.png)


## 调度

当有一堆任务要处理，但是由于资源有限，这些事情没法同时处理。这就需要确定某种规则来决定处理这些任务的顺序，这就是调度研究的问题
![image.png](https://yaaame-1317851743.cos.ap-beijing.myqcloud.com/undefinedPasted%20image%2020230518103314.png)
- 低级调度 就绪队列->处理机
- 中级调度 内存<->外存
- 高级调度 外存->创建 就绪态
![image.png](https://yaaame-1317851743.cos.ap-beijing.myqcloud.com/undefinedPasted%20image%2020230518103242.png)


## 同步

竞争条件：多个进程并发访问和操作同一数据并且执行结果与特定执行顺序有关

### 临界区问题

临界区：进程在执行该区时可能修改公共变量；当一个进程在临界区执行时，其他进程不允许在他们的临界区内执行

临界区的解决方案应满足如下三条件：
- 互斥
- 进步：只能从进入区选择
- 有限等待

### Peterson软件解决方案

适用于两个进程交错执行临界区和剩余区

```c
do
{
    flag[i]=true;//进程i准备进入临界区
    turn=j;//j进程可以进入临界区
    while(flag[i]&&turn==j);
    -
    - 临界区
    -
    flag[i]=false;
    -
    - 剩余区
    - 
}while(true);
```
-------------- 进程i的结构 ----------


### 硬件同步

基于加锁为前提

原子指令：

```c
boolean test_and_set(boolean *target)
{
    boolean rv=*target;
    *target=true;
    return rv;
}

do
{
    //初始化lock=false;
    while(test_and_set(&lock));
    -
    - 临界区
    - 
    lock=fasle;
    
}while(true);
```





### 互斥锁 mutex lock

自旋锁：需要忙等待，当有一个进程进入临界区时，任何其他进程在进入临界区时必须连续循环调用acquire()，即进程不断旋转
其优点：进程在等待锁时，没有上下文切换，因此当使用锁的时间较短时，自旋锁还是有用的


```c
//获取锁
acquire()
{
    while(!available);
    available=false;
    -
    -
    -
}



//释放锁
release()
{
    available=true;
}
```


### 信号量 semaphore

一个信号量S是一个整形变量，它除了初始化外只能通过两个标准原子操作 wait() 和 signal() 来实现，wait() 称为P，signal()称为V

```c
wait(S)
{
    while(S<=0);
    S--;
}

signal(S)
{
    S++;
}
```

当一个进程修改信号量时，没有其他进程能够同时修改同一信号量的值


#### 信号量的使用

二进制信号量类似于互斥锁

计数信号量可以用于控制访问具有多个实例的某种资源

### 经典同步问题


#### 有界缓冲区问题

```c
void *producer(void *param)
{
        srand(time(NULL));
        int *count=(int*)param;
        for(int i=0;i<*count;i++)
        {
                int value=rand()%10;
                sem_wait(&empty);
                sem_wait(&mutex);
                BUFFER[in]=value;
                printf("producer produce a %d \n",value);
                in=(in+1)%SIZE;
                sem_post(&full);
                sem_post(&mutex);

        }
        pthread_exit(NULL);
}
void *consumer(void *param)
{

        int *count=(int*)param;
        for(int i=0;i<*count;i++)
        {
                sem_wait(&full);
                sem_wait(&mutex);
                int value=BUFFER[out];
                printf("consumer consume a %d \n",value);
                out=(out+1)%SIZE;
                sem_post(&mutex);
                sem_post(&empty);

        }
        pthread_exit(NULL);
}
```

#### 读者-作者问题


#### 哲学家就餐问题
















## 死锁

形成死锁的四大必要条件
- 资源以互斥方式使用
- 持有并等待
- 已持有资源不可被剥夺
- 循环等待

![image.png](https://yaaame-1317851743.cos.ap-beijing.myqcloud.com/undefinedPasted%20image%2020230518111100.png)

![image.png](https://yaaame-1317851743.cos.ap-beijing.myqcloud.com/undefinedPasted%20image%2020230427095413.png)


### 死锁处理

#### 死锁预防

##### 进程必须获取工作所需所有资源，才能开展工作（破坏持有并等待）
- 进程 ：运行前申请所需全部资源
- 系统 ：对于任意一个进程的资源申请，如果能够满足，则一次性全部分配，否则让进程等待

缺点：
- 资源利用率低
- 并发度低


##### 要求进程按序使用资源（破坏循环等待）

对资源进行编号，约定按照编号大小顺序进行资源分配

#### 死锁避免

寻找安全序列
![image.png](https://yaaame-1317851743.cos.ap-beijing.myqcloud.com/undefinedPasted%20image%2020230427104326.png)

##### 银行家算法
![image.png](https://yaaame-1317851743.cos.ap-beijing.myqcloud.com/undefinedPasted%20image%2020230427105419.png)
![image.png](https://yaaame-1317851743.cos.ap-beijing.myqcloud.com/undefinedPasted%20image%2020230427104445.png)

死锁检测时机：
- 当进程阻塞时
- 定时检测
- 系统资源利用率下降时

死锁解除
- 重新启动
- 撤销进程
- 剥夺进程资源
- 进程回退



## 主存管理

在计算机中，每个进程都有自己的虚拟地址空间，这些虚拟地址需要通过MMU转换成对应的物理地址才能被硬件访问。虚拟地址空间包括用户空间和系统空间，用户空间用于存储进程的代码和数据，而系统空间用于存储操作系统的代码和数据。虚拟地址可以被映射到真正的物理内存地址或者磁盘上的虚拟页文件，这个映射关系是可以被修改和调整的。物理地址是主存中特定单元的内存地址，可以通过数据总线访问。MMU负责将虚拟地址转换成物理地址，并通过总线访问相应的内存单元，以完成读写操作。


- 内存绑定
- 内存分配
- 内存保护
    - 进程不可访问其他进程地址空间的地址
- 内存扩充

#### 地址绑定

逻辑地址与物理地址的映射·

- 编译时绑定
    - 缺点 不灵活 load地址被占用，则需要重新编译，调整入口地址


![](https://dder.oss-cn-beijing.aliyuncs.com/20230504104413.pngx-oss-process=style/stylenam![image.png](https://dder.oss-cn-beijing.aliyuncs.com/20230504104558.pngx-oss-process=style/stylename)
#### 内存分配

##### 连续内存分配

为每个进程分配连续的内存
- 固定大小分区
    - 使用数组来记录各个连续内存快的分配情况
    - 会造成分区内资源浪费 形成内部碎片
- 动态分区分配
    - 采用链表记录某时刻内存中未分配的块
    - 造成内存空间碎片块

- 最先适配算法  从空闲块中选择$\geq SIZE$ 的首个块
    - 链表实现  地址升序
    - 存在外部碎片问题
- 最佳适配算法  将空闲表从小到大排序 从空闲块中选择$\geq SIZE$ 的首个块
    - 链表实现  空间块大小升序
    - 容易产生细小的外部碎片
- 最差适配算法  从空闲块中选择$\geq SIZE$ 的最大块
    - 链表实现  空间块大小降序
    - 存在外部碎片问题

碎片大小跟进程大小和空闲块大小相关，不可控

##### 分页机制

```
页式管理机制是一种计算机内存管理方式，将物理内存划分为固定大小的页框，并将进程的虚拟地址空间划分为固定大小的页。每个进程都有自己的页表，用于将进程的虚拟地址映射到物理地址。优点包括空间利用率高、保护机制强、负载平衡、灵活性强；缺点包括页表较大、物理内存不连续、页面置换开销大。需要根据具体情况选择合适的内存管理方式。
```

使用分散的页满足进程的内存分配申请

连续分区导致较大碎片问题，引入分页机制加以控制，内部碎片大小不会超过一个页，外部碎片问题解决

分页：将逻辑地址和进程的地址空间按页划分，每个页代表一组连续的地址

- 地址划分
    - 地址被拆为页号和页内偏移两部分
- 建立地址映射 页表
- 地址翻译

![image.png](https://yaaame-1317851743.cos.ap-beijing.myqcloud.com/undefinedPasted%20image%2020230508083509.png)

- 单级页表 ：页表占据空间过大
- 多级页表 哈希页表 反置页表

![[cover441_20230508074804.jpg]]

38位  逻辑地址空间 2^38
页面大小 16kB  2^14
页号空间大小 2^24
二级页表 每一页 2^12
32位物理地址
2^12 * 4B=2^14B=16kB


##### 分段机制

操作系统的分段机制是指将内存按照一定的大小划分为不同的段，每个段分别用于存放不同类型的数据，如代码、数据、栈等。这种机制可以有效地隔离不同进程或任务使用的内存空间，避免它们之间互相干扰。

具体来说，分段机制会为每个进程分配一组属于它自己的段集合，CPU 的硬件机制会保证其代码不会越权访问段，也不会访问到段外的地址。这样就可以有效地保障进程之间的内存隔离和安全性。



![image.png](https://yaaame-1317851743.cos.ap-beijing.myqcloud.com/undefinedPasted%20image%2020230511095551.png)









#### 内存保护

为每个进程分配一块内存区，设置分区基地址和分区大小

借助硬件保护机制，进行内存保护，利用软件保护会使系统效率下降


#### 内存扩充

swap：虚存机制的重要基础

通过交换控制系统动态调整系统中的多道程序度


### 内存管理硬件单元 MMU 

内存管理硬件单元（Memory Management Unit，MMU）是一种计算机硬件，主要负责处理中央处理器（CPU）的内存访问请求。其主要功能包括虚拟地址到物理地址的转换（即虚拟内存管理）、内存保护和中央处理器高速缓存。通过使用MMU，每个进程都可以拥有自己的独立地址空间，从而实现更好的内存管理和安全性。

MMU的作用在于将虚拟地址空间映射到物理地址空间。当程序需要访问一个虚拟地址时，MMU会根据内存管理的配置进行地址转换，并对转换后的物理地址进行访问。同时，MMU还可以进行内存保护，即限制某些进程访问特定的内存区域，以提高系统的安全性。

然而需要注意的是，不同的操作系统和架构会有不同的内存管理方案和MMU实现。例如，x86架构的MMU采用分页机制进行地址转换，而ARM架构则采用段页式内存管理机制。此外，MMU的性能也会对系统整体性能产生影响，因此在选择硬件设计或操作系统时需要考虑这些因素。

![[cover429_20230508074751.jpg]]

TLB ：降低分页管理开销的硬件缓存方案
![[cover437_20230508074756.jpg]]


## 虚存管理

用较少的物理地址，支撑较大的逻辑地址空间


![image.png](https://yaaame-1317851743.cos.ap-beijing.myqcloud.com/undefinedPasted%20image%2020230511101356.png)

##### 实现虚存的关键技术
- 按需分配
- 惰性加载

理论依据： 程序的局部性原理


##### 引入虚存的意义

- 形成较大虚存空间
- 便于进程间内存共享
- 按需调页 设页表有效位

![[cover461_20230511094358.jpg]]
![[cover460_20230511094358.jpg]]


#### 页面置换算法

![[cover465_20230511094401.jpg]]

1 2 3 4
1 1

5 6 2 1 
     1
     
3 7 6 2
1 

1 7 6 2
        1

3 7 6 2
     1

命中情况  6/20=0.3
页故障次数  14


1 2 3 4 
1 1

1 2 3 5

1 2 3 6
1 1 1 

7 2 3 6
  1 1 1

1 2 3 6
  1 1 1
  
命中情况 ：11次
页故障次数 ：20-11=9次



1 2 3 4
1 1

1 2 5 6
1 2

1 2 3 7
1 2 1

1 2 3 6

命中情况 9
故障次数 11

![image.png](https://yaaame-1317851743.cos.ap-beijing.myqcloud.com/undefinedPasted%20image%2020230515080414.png)

#### 页置换算法实现

##### 基于引用位的页置换算法

通过硬件维护一个引用位
- 每次访问一个页面，将该页面引用位置1
- 根据算法在合理时间内将页面引用位置0

页置换：
    优先置换引用位为0的页面


- 附加引用算法
    - 页面引用位R，附加引用位ARB
    - 每次置换ARB最小的页
- 二次机会算法
    - 采用循环链表
    - 引用位为1的页面，不会立即被置换

#### 页帧分配

![image.png](https://yaaame-1317851743.cos.ap-beijing.myqcloud.com/undefinedPasted%20image%2020230515084109.png)

进程页帧分配过少：出现**内存抖动**，页面被频繁的换入换出，导致程序大部分时间在换入换出

内存抖动的原因
- 页置换算法不当
- 系统内进程过多，太高的多道程序度

#### 内核内存分配

伙伴算法



## 文件系统


文件是文件系统中的核心要素

文件系统是操作系统的核心模块

操作系统安装时，主要工作是 创建系统分区，并在系统分区建立根系统


文件是外存上存储信息的基本单元，每个文件代表一段连续的逻辑数据


#### 文件的逻辑结构

![image.png](https://yaaame-1317851743.cos.ap-beijing.myqcloud.com/undefinedPasted%20image%2020230522083045.png)

##### 流式文件

文件结构在OS层面被看成是无结构的字节流或字符流，以字节为单位编址

##### 记录式文件

![image.png](https://yaaame-1317851743.cos.ap-beijing.myqcloud.com/undefinedPasted%20image%2020230522082221.png)



#### 文件操作

![image.png](https://yaaame-1317851743.cos.ap-beijing.myqcloud.com/undefinedPasted%20image%2020230522083528.png)

##### 文件访问模式

- 顺序访问
    - 典型代表：编译器，磁带等顺序访问设备
- 直接(随机)访问
    - 磁盘等随机访问设备
- 索引访问


#### 分区目录结构


##### 分区结构 

- MBR Master Boot Record
![image.png](https://yaaame-1317851743.cos.ap-beijing.myqcloud.com/undefinedPasted%20image%2020230522090548.png)

- GPT 
![image.png](https://yaaame-1317851743.cos.ap-beijing.myqcloud.com/undefinedPasted%20image%2020230522090518.png)


#### 目录结构

从逻辑上，文件系统由一组目录和文件组成

目录访问按名访问


#### 


## 大容量管理

## 磁盘调度算法


![image.png](https://yaaame-1317851743.cos.ap-beijing.myqcloud.com/undefinedPasted%20image%2020230601101408.png)




















