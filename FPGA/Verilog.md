
## 数值表示

#### 电平逻辑
- 0
- 1
- x 未知 意味着数值信号的不确定
- z 高阻 意味着信号处于高阻状态，常见于信号（input，reg）没有驱动时的逻辑结果

#### 数值表示方法

- 十进制 'd 'D 
- 二进制 'b 'B
- 八进制 'o 'O
- 十六进制 'h 'H

```verilog
4'b1011 // 4bit数值
32'h3022_c0de //32bit数值

-6'd15  //负数
-15

```

#### 字符串

字符串是由双引号包起来的字符队列。字符串不能多行书写，即字符串中不能包含回车符。Verilog 将字符串当做一系列的单字节 ASCII 字符队列。例如，为存储字符串 "www.runoob.com", 需要 14*8bit 的存储单元


## 数据类型


#### 线网 wire

表示硬件之间的物理连线，由其连接的器件输出端连续驱动。如果没有驱动元件连接到wire型变量，缺省值一般为”Z“

```verilog
wire   interrupt ;  
wire   flag1, flag2 ;  
wire   gnd = 1'b0 ;
```
#### 寄存器 reg

寄存器用老表示存储单元，它会保持数据原有的值，直到被改写

```verilog
reg    clk_temp;  
reg    flag1, flag2 ;
```
寄存器不需要驱动源，也不一定需要时钟信号


#### 向量

当位宽大于1时，wire或reg即可声明成向量的形式

```verilog
reg [3:0]      counter ;    //声明4bit位宽的寄存器counter  
wire [32-1:0]  gpio_data;   //声明32bit位宽的线型变量gpio_data  
wire [8:2]     addr ;       //声明7bit位宽的线型变量addr，位宽范围为8:2  
reg [0:31]     data ;       //声明32bit位宽的寄存器变量data, 最高有效位为0


//下面 2 种赋值是等效的  
A = data1[31-: 8] ;  
A = data1[31:24] ;  
  
//下面 2 种赋值是等效的  
B = data1[0+ : 8] ;  
B = data1[0:7] ;

```

#### 整数 实数 时间寄存器变量

##### 整数 integer

```verilog
reg [31:0]      data1 ;  
reg [3:0]       byte1 [7:0]; //数组变量，后续介绍  
integer j ;  //整型变量，用来辅助生成数字电路  
always@* begin  
    for (j=0; j<=3;j=j+1) begin  
        byte1[j] = data1[(j+1)*8-1 : j*8];  
        //把data1[7:0]…data1[31:24]依次赋值给byte1[0][7:0]…byte[3][7:0]  
        end  
end
```
##### 实数 real

实数用关键字 real 来声明，可用十进制或科学计数法来表示。实数声明不能带有范围，默认值为 0。如果将一个实数赋值给一个整数，则只有实数的整数部分会赋值给整数

```verilog
real        data1 ;  
integer     temp ;  
initial begin  
    data1 = 2e3 ;  
    data1 = 3.75 ;  
end  
   
initial begin  
    temp = data1 ; //temp 值的大小为3  
end
```

##### 时间

Verilog 使用特殊的时间寄存器 time 型变量，对仿真时间进行保存。其宽度一般为 64 bit，通过调用系统函数 $time 获取当前仿真时间

```verilog
time       current_time ;  
initial begin  
       #100 ;  
       current_time = $time ; //current_time 的大小为 100  
end
```

##### 数组

```verilog
integer          flag [7:0] ; //8个整数组成的数组  
reg  [3:0]       counter [3:0] ; //由4个4bit计数器组成的数组  
wire [7:0]       addr_bus [3:0] ; //由4个8bit wire型变量组成的数组  
wire             data_bit[7:0][5:0] ; //声明1bit wire型变量的二维数组  
reg [31:0]       data_4d[11:0][3:0][3:0][255:0] ; //声明4维的32bit数据变量数组
```
##### 参数  parameter

参数用来表示常量，只能赋值一次

```verilog
parameter      data_width = 10'd32 ;  
parameter      i=1, j=2, k=3 ;  
parameter      mem_size = data_width * 10 ;
```


##

![[Pasted image 20230427111207.png]]
```verilog
assign out=~in;//notgate
assign out=a&b;//andgate
assign out=~(a|b);//norgate
assign out=a^b;//xorgate
assign out=a~^b;//xnorgate
```

## 表达式

#### 算术操作符

```
乘（*）、除（/）、加（+）、减（-）、求幂（**）、取模（%）
如果操作数某一位为 X，则计算结果也会全部出现 X。
无符号数乘法时，结果变量位宽应该为 2 个操作数位宽之和

```
#### 关系操作符

```
大于（>），小于（<），大于等于（>=），小于等于（<=）
如果操作数中有一位为 x 或 z，则关系表达式的结果为 x
```

#### 等价操作符

```
逻辑相等（==），逻辑不等（!=），全等（===），非全等（!==）
等价操作符的正常结果有 2 种：为真（1）或假（0）。

逻辑相等/不等操作符不能比较 x 或 z，当操作数包含一个 x 或 z，则结果为不确定值。

全等比较时，如果按位比较有相同的 x 或 z，返回结果也可以为 1，即全等比较可比较 x 或 z。所以，全等比较的结果一定不包含 x
```
```verilog
A = 4 ;  
B = 8'h04 ;  
C = 4'bxxxx ;  
D = 4'hx ;  
A == B        //为真  
A == (B + 1)  //为假  
A == C        //为X，不确定  
A === C       //为假，返回值为0  
C === D       //为真，返回值为1
```

#### 逻辑操作符

```
&&（逻辑与）, ||（逻辑或），!（逻辑非）

逻辑操作符的计算结果是一个 1bit 的值，0 表示假，1 表示真，x 表示不确定

如果一个操作数不为 0，它等价于逻辑 1；如果一个操作数等于 0，它等价于逻辑 0。如果它任意一位为 x 或 z，它等价于 x。

如果任意一个操作数包含 x，逻辑操作符运算结果不一定为 x
```

```verilog
A = 3;  
B = 0;  
C = 2'b1x ;  
     
A && B    //     为假  
A || B    //     为真  
! A       //     为假  
! B       //     为真  
A && C    //     为X，不确定  
A || C    //     为真，因为A为真  
(A==2) && (! B)  //为真，此时第一个操作数为表达式
```

#### 按位操作符

```
取反（~），与（&），或（|），异或（^），同或（~^）
如果 2 个操作数位宽不相等，则用 0 向左扩展补充较短的操作数。

取反操作符只有一个操作数，它对操作数的每 1bit 数据进行取反操作

```

#### 归纳操作符

```
归约与（&），归约与非（~&），归约或（|），归约或非（~|），归约异或（^），归约同或（~^）

```
```verilog
A = 4'b1010 ;
&A ;      //结果为 1 & 0 & 1 & 0 = 1'b0，可用来判断变量A是否全1
~|A ;     //结果为 ~(1 | 0 | 1 | 0) = 1'b0, 可用来判断变量A是否为全0
^A ;      //结果为 1 ^ 0 ^ 1 ^ 0 = 1'b0

```
#### 移位操作符

```
左移（<<），右移（>>），算术左移（<<<），算术右移（>>>）

```

#### 条件操作符

```verilog
assign   hsel = (addr[9:8] == 2'b00) ? hsel_p1 :  
                (addr[9:8] == 2'b01) ? hsel_p2 :  
                (addr[9:8] == 2'b10) ? hsel_p3 :  
                (addr[9:8] == 2'b11) ? hsel_p4 ;
```
